<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[OS内list.h函数部分讲解]]></title>
    <url>%2F2020%2F04%2F13%2Flist-h%2F</url>
    <content type="text"><![CDATA[List.h部分函数初始化操作 首先，向函数内部传入链表头节点 在函数中，使头节点的pre以及next指针指向头节点 ，即 next = pre = head 参考代码 static inline void list_init(ListHead *list) &#123; list-&gt;prev = list-&gt;next = list;&#125; 效果图 判断空操作 首先，向函数内部传入链表头节点 在函数中，判断头节点是否与它的其中一个指针分量值相同，若相同，则返回true，否则返回false 参考代码 static inline boolean list_empty(ListHead *list) &#123; return list == list-&gt;next;&#125; 向头节点后部添加节点操作 首先，向函数内部传入链表头节点以及要插入节点的listhead分量指针 在函数中调用List_add()函数 第一个参数为链表头节点指针 第二参数为链表头节点下一个节点的指针 第三个参数为待插入节点的listhead分量指针 接下来分析List_add()函数 首先判断待插入节点的listhead分量指针是否为空，如果为空，则退出程序，否则，执行以下步骤 在这里 参数 pre = head next = head-&gt;next data为待插入节点的listhead分量指针 （第一次插入 其实质为 next = pre = head ， 第i次插入其实质为 pre = head next = 上一个插入节点的listhead分量指针） 首先，待插入节点的listhead分量指针的pre分量设置成pre参数值 待插入节点的listhead分量指针的next分量设置成next参数值 最后，设置参数pre的next等于data，数next的pre等于data 参考代码 static inline void list_add_after(ListHead *list, ListHead *data) &#123; list_add(list, list-&gt;next, data);&#125;static inline void list_add(ListHead *prev, ListHead *next, ListHead *data) &#123; assert(data != NULL); //报错&amp;&amp;终止程序！ data-&gt;prev = prev; data-&gt;next = next; if (prev != NULL) prev-&gt;next = data; if (next != NULL) next-&gt;prev = data;&#125; 只插一个节点的效果图 插两个节点的过程图 插两个节点的效果图 向头节点前部添加节点操作 在这里，我们只需比较传入List_add()函数参数就可以了 在list_after函数中， pre = 头节点地址 next = 头节点的后继节点地址 data为待插入节点的listhead分量指针 而在list_before函数中，pre = 头节点的前驱节点地址 next = 头节点地址 data为待插入节点的listhead分量指针 参考代码 static inline voidlist_add_before(ListHead *list, ListHead *data) &#123; list_add(list-&gt;prev, list, data);&#125;static inline void list_add(ListHead *prev, ListHead *next, ListHead *data) &#123; assert(data != NULL); //报错&amp;&amp;终止程序！ data-&gt;prev = prev; data-&gt;next = next; if (prev != NULL) prev-&gt;next = data; if (next != NULL) next-&gt;prev = data;&#125; 只插一个节点的效果图 插两个节点的过程图 插两个节点的效果图 删除链表中节点操作 我们只需向list_del()函数中传入要删除节点的指针 首先，我们需要判断是否删除的指针为空，如果为空，则直接报错退出，否则，进行下一步 接下来，我们设置两个指针保护要删除节点的前驱节点(pre)地址以及后继节点(next)地址 最后我们先判断pre以及next是否为空，如果为空，无需任何操作，否则，将 前驱节点(pre)的后继节点指针next设置为后继节点next 后继节点(next)的前驱节点指针pre设置为前驱节点pre 参考代码 static inline void list_del(ListHead *data) &#123; assert(data != NULL); ListHead *prev = data-&gt;prev; ListHead *next = data-&gt;next; if (prev != NULL) prev-&gt;next = next; if (next != NULL) next-&gt;prev = prev;&#125; 删除节点过程图 删除节点效果图 获取结构体起始指针 0x0地址强制转换为type *类型，然后取type中的成员member地址，因为起始地址为0，得到的member的地址就直接是该成员相对于type对象的偏移地址了。 所以该语句的功能是：得到type类型对象中member成员的地址偏移量。 先将ptr强制转换为char *类型（因为char *类型进行加减的话，加减量为sizeof(char)*offset，char占一个字节空间，这样指针加减的步长就是1个字节，实现加一减一。） 整句话的意思就是：得到指向type的指针，已知成员的地址，然后减去这个成员相对于整个结构对象的地址偏移量，得到这个数据对象的地址。 参考代码 #define list_entry(ptr, type, member) \ ((type*)((char*)(ptr) - (int)(&amp;((type*)0)-&gt;member))) 解析图 谢谢访问]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>List.h</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubunte 代码初步]]></title>
    <url>%2F2020%2F02%2F21%2Fubunte-%E4%BB%A3%E7%A0%81%E5%88%9D%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[安装环境针对Ubunte 18.04版本，安装一下环境 gcc安装代码 sudo apt-get install build-essential 或者使用代码 sudo apt-get build-dep gcc g++安装代码 sudo apt-get install g++ VI使用初步创建(或打开已有)文件，同时进入命令模式 vi sum.c 进入输入模式、编辑文件 esc键 + : set nocp 回到命令模式 esc键 保存文件并退出 :wq 执行C文件 方法一 gcc sum.c./a.out 方法二 gcc sum.c -o sum.\sum C文件内容及运行代码 C文件内容 #include &lt;stdlib.h&gt;int main()&#123; int i = 1 , sum = 0; for(i = 1 ; i &lt;= 100 ; ++i)&#123; sum += i; &#125; printf("%d\n",sum); return 0 ;&#125; 运行结果 谢谢访问]]></content>
      <categories>
        <category>UNIX程序设计</category>
      </categories>
      <tags>
        <tag>vi&amp;&amp;vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Navicat安装]]></title>
    <url>%2F2020%2F02%2F10%2FNavicat%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[前言今天破解Navicat15，本来想申请学生教育免费，结果两天后客服告诉我需要学生邮箱，可惜没有.edu.cn邮箱，无奈只好破解。 软件相关链接Navicat Premium15中文版 注册机 使用方法 正版软件安装时候要断网 安装完成后不要打来 之后把注册机粘贴到软件安装目录下 打开注册机，点击”patch”按钮，成功的话会弹出对框“navicat.exe-x64-&gt;Cracked!”字样。 现在运行Nacicat,会弹出窗口提示你只能用14天，这时候点击“注册”，点了之后要你输入激活码的窗口。回到注册机，点“Generate”,复制激活码，输入到软件中，点击确认 这时候软件会弹出由于没网，这时点击“手动注册” 下一个界面里会有一大段的”请求码“，复制下来粘贴到注册机里，并点击最下方的”Generate“按钮，会生成注册码，复制回去激活即可。 好好享受吧！ 谢谢访问]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>Navicat15安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序列求和]]></title>
    <url>%2F2019%2F12%2F31%2F%E5%BA%8F%E5%88%97%E6%B1%82%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目描述求1+2+3+…+n的值。 输入格式输入包括一个整数n。 输出格式输出一行，包括一个整数，表示1+2+3+…+n的值。 样例输入4 样例输出10 样例输入100 样例输出5050 数据规模与约定1 &lt;= n &lt;= 1,000,000,000。 思路 计算1 … n的和 注意，递归一定暴栈，循环一定超时 要使用数学公式对其进行归纳 参考代码#include &lt;bits/stdc++.h&gt;using namespace std;int main(int argc, char const *argv[])&#123; long long n = 0 ; cin &gt;&gt; n ; long long sum = 0 ; if (n % 2 == 0) &#123;sum = n /2 * n + n / 2;&#125; else &#123;sum = n/2 * n + n;&#125; cout &lt;&lt; sum ; return 0;&#125; 蓝桥杯初级题目总结 1.不要使用递归，必须使用动规 2.注意每个题都极大可能有其对应数学公式(即一定有优化部分),否则一定超时 谢谢访问]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>竞赛</category>
        <category>初级</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>蓝桥杯</tag>
        <tag>初级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[圆的面积]]></title>
    <url>%2F2019%2F12%2F31%2F%E5%9C%86%E7%9A%84%E9%9D%A2%E7%A7%AF%2F</url>
    <content type="text"><![CDATA[题目描述给定圆的半径r，求圆的面积。 输入格式输入包含一个整数r，表示圆的半径。 输出格式输出一行，包含一个实数，四舍五入保留小数点后7位，表示圆的面积。 样例输入4 样例输出50.2654825 数据规模与约定1 &lt;= r &lt;= 10000。 思路一定要记住Π的求法公式 double PI=atan(1.0)*4; 参考代码#include &lt;bits/stdc++.h&gt;using namespace std;int main(int argc, char const *argv[])&#123; double PI=atan(1.0)*4; int r = 0 ; cin &gt;&gt; r ; double result = 0 ; result = PI*r*r; printf("%0.7f",result); return 0;&#125; 谢谢访问]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>竞赛</category>
        <category>初级</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>蓝桥杯</tag>
        <tag>初级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fibonacci数列]]></title>
    <url>%2F2019%2F12%2F31%2FFibonacci%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述Fibonacci数列的递推公式为：Fn=Fn-1+Fn-2，其中F1=F2=1。 当n比较大时，Fn也非常大，现在我们想知道，Fn除以10007的余数是多少。 输入格式 输入包含一个整数n。 输出格式 输出一行，包含一个整数，表示Fn除以10007的余数。 样例输入10 样例输出55 样例输入22 样例输出7704 数据规模与约定1 &lt;= n &lt;= 1,000,000。 思路归会暴栈，如果求出最后的F[N]，则F[N]已经溢出，故需要利用动态规划+等价类 公式： dp[1] = 1 ; dp[2]= 1 ; for(int i = 3 ; i &lt;= n ; ++i) {dp[i] = (dp[i-1] + dp[i-2])%10007; 参考代码#include &lt;bits/stdc++.h&gt;using namespace std;int main(int argc, char const *argv[])&#123; int n = 0 ; cin &gt;&gt; n ; vector&lt;int&gt; dp(n+1); dp[1] = 1 ; dp[2]= 1 ; for(int i = 3 ; i &lt;= n ; ++i) &#123;dp[i] = (dp[i-1] + dp[i-2])%10007;&#125; cout &lt;&lt; dp[n]; return 0;&#125; 谢谢访问]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>竞赛</category>
        <category>初级</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>蓝桥杯</tag>
        <tag>初级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Banch_limit_Tsp]]></title>
    <url>%2F2019%2F11%2F23%2FBanch-limit-Tsp%2F</url>
    <content type="text"><![CDATA[问题描述设有n个城市，城市之间道路的长度均大于或等于0，还可能是∞（对应城市之间无交通线路）。一个旅行商从某个城市出发，要经过每个城市一次且仅一次，最后回到出发的城市，问他如何走才能使他走的路线最短？ 要求：优先使用矩阵归约确定限界函数的方法，或者其他方法实现。 问题分析 对于这个问题，我们采用广度优先遍历，把从起点到其他未曾走过的边的权权入队(优先队列)。 接下来每次从队中取出最小的权的元素，在其进行广度优先遍历，即从此点到其他未曾走过的边的权加上他本来的权的元素入队 结束条件，第一个所有节点都被访问过的元素被出队。 最后被出队元素在加上其最后一个被访问节点到起点的边的权 算法分析 首先从文件读取节点数量以及边数量、起点、边的权信息。所用时间T = O(n) 接着构造优先队列，所用时间 T = O(nlogn) 接下来将起点到其他个点距离入队，所用时间T = (n-1)O(log n) 之后设置while循环，每次从队中取出最小的权的元素，进行广度优先遍历，将从此点到其他未曾走过的边的权加上他本来的权的元素入队。 所用时间T = O(n) (搜索未访问节点) + (n - deep)O(log n) (入队元素) +一次出队O(log n) 总时间约为T = O(nlogn) 参考代码#include &lt;bits/stdc++.h&gt;using namespace std;typedef struct&#123; int meter = 0 ; int pos = 0 ; int v[10]; int cnt = 0;&#125;ties;bool operator&lt;(ties a, ties b) &#123; return a.meter &gt; b.meter;&#125;int main()&#123; char buffer[200]; ifstream in("bandary_TSP.txt"); int number = 0 , side = 0 , source = 0; in.getline(buffer,20); sscanf(buffer,"%d%d%d",&amp;number,&amp;side,&amp;source); vector&lt;vector&lt;int&gt; &gt; v(number+1); for(int i = 1 ; i &lt; v.size() ;++i) &#123;v[i].resize(number+1);&#125; for(int i = 1 ; i &lt;= side ;++i) &#123; int m = 0 , n = 0 , w = 0; in.getline(buffer,20); sscanf(buffer,"%d%d%d",&amp;m,&amp;n,&amp;w); v[m][n] = w ; v[n][m] = w ; &#125; priority_queue&lt;ties&gt; q; for(int i = 1 ; i &lt;= number ; ++i)&#123; if(i != source) &#123; ties temp ; temp.meter = v[source][i]; temp.v[source] = 1 ; temp.pos = i ; temp.cnt += 1 ; q.push(temp); &#125; &#125; while(!q.empty())&#123; ties temp = q.top(); temp.cnt += 1 ; if(temp.cnt + 1 == number)&#123; for(int i = 1 ;i &lt;= number ; ++i)&#123; if(temp.v[i] != 1)&#123; cout &lt;&lt; temp.meter+v[temp.pos][i]; return 0; &#125; &#125; &#125; q.pop(); for(int i = 1 ; i &lt;= number ; ++i)&#123; if(temp.v[i] != 1 &amp;&amp; i != temp.pos )&#123; temp.meter += v[temp.pos][i]; temp.v[temp.pos] = 1; temp.v[i] = 1; temp.pos = i ; q.push(temp) ; &#125; &#125; &#125; return 0; &#125; 谢谢访问]]></content>
      <categories>
        <category>算法课下实验</category>
        <category>Banch_limit_Tsp</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Banch_limit_0-1pacage]]></title>
    <url>%2F2019%2F11%2F23%2FBanch-limit-0-1pacage%2F</url>
    <content type="text"><![CDATA[问题描述 0-1背包问题 已知n个物品的价值vi和重量wi，背包的载重W，求能放入背包的最大价值。用分支限界方法解决此问题 问题分析该背包是0-1背包，只有背包里的物品放与不放两种选择。在本题中，题目要求使用分支限界方法求解。故需要确定一下背包放物品的上界以及下界。 求上界： ​ 即比背包放的实际最大价值要大。 ​ 计算方法：max(物品单位重量最大值) 背包容积 ​ 求下界： ​ 在这里我们使用贪心算法，求得放入背包的物品价值最少不能低于该值 ​ 计算方法：优先选择价值高的物品放入，直到背包不能再放入任何其他物品 确定上下界以后，对背包每个物品分放与不放两种情况分析： 放：则要注意放入后的背包所剩体积(c – w )要大于零，否则不放。 ​ 若能放入，则有 ​ w=w+goods.weight ​ v = v +goods.value ​ vb = v + (剩余没放的物品中物品单位重量最大值)剩余背包容量 ​ vb用于时刻计算物品背包当前状态下到最后的最大价值 ​ 若vb值不小于由贪心算法求得的下界，则入队，否则不入队 ​ 不放： ​ 则需要更新此时情况的最大上界 ​ vb = v + (剩余没放的物品中物品单位重量最大值)剩余背包容量 ​ 若vb值不小于由贪心算法求得的下界，则入队，否则不入队 ​ 出口条件： ​ 出队元素的w足够大，以至于不能放入任何物品 算法分析首先从文件读取背包以及物品信息。所用时间T = O(n) 其次使用贪心算法求出物品下界，需要对物品按照价值做降序的快速排序，然后再使用一重循环，计算好下界。所用时间T = O(nlogn) + O(n) = O(nlogn) 之后使用优先队列，优先队列设置为大顶堆，每次弹出此时背包实际价值最大的元素出队，进行放与不放的操作。 由于优先队列用堆来实现，具有O(log n)时间复杂度的插入元素性能，O(n)的初始化构造的时间复杂度。插入与删除的时间复杂度为O(log n)，构造二叉树的时间复杂度为O(n log n) 所以此步的时间复杂度大概为T =O(nlogn) +O(logn)约等于O(nlogn)* 最终该算法时间复杂度为T =O(n)+ O(nlogn) +O(nlogn)约等于O(nlogn) 分支限界的认识 以广度优先或以最小耗费（最大效益）优先的方式搜索问题的解空间树 分支限界法中，每一个活结点只有一次机会成为扩展结点，活结点一旦成为扩展结点，就一次性产生其所有儿子结点，其中导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被加入活结点表中 然后从活结点表中取下一结点成为当前扩展结点 重复上述结点扩展过程，直至到找到所需的解或活结点表为空时为止 分支限界与回溯法区别 求解目标不同 回溯法的求解目标是找出解空间树中满足约束条件的所有解 分支限界法的求解目标则是尽快找出满足约束条件的一个解，或是在满足约束条件的解中找出在某种意义下的最优解 搜索方式不同 回溯法以深度优先的方式（遍历结点）搜索解空间树 分支限界法以广度优先或最小耗费优先的方式搜索解空间树 对扩展结点的扩展方式不同 分支限界法中，每一个活结点只有一次机会成为扩展结点活结点一旦成 为扩展结点，就一次性产生其所有儿子结点 存储空间的要求不同 分支限界法的存储空间比回溯法大得多，因此当内存容量有限时，回溯法成 功的可能性更大 参考代码#include &lt;bits/stdc++.h&gt;using namespace std;typedef struct&#123; double value = 0.00; double weight = 0.00; double pervalue = 0.00;&#125;goods;//---------------------------typedef struct&#123; double w = 0 ; double v = 0; double vb = 0; int next = 0;&#125;point;//-------------------------bool operator&lt;(point a, point b) &#123; return a.v &gt; b.v;&#125;//----------------------------bool cmp(goods a , goods b)&#123; if(a.pervalue == b.pervalue)&#123; return a.weight &lt; b.weight; &#125; return a.pervalue &gt; b.pervalue;&#125;//-----------------------------int main()&#123; //file operate char buffer[200]; ifstream in("0-1pacage.txt"); int number = 0 , c = 0 ; in.getline(buffer,20); sscanf(buffer,"%d%d",&amp;number,&amp;c); vector&lt;goods&gt; v(number+1) ; for(int i = 1 ; i &lt; v.size() ; ++i)&#123; double value = 0 , weight = 0 ; in.getline(buffer,20); sscanf(buffer,"%lf%lf",&amp;weight,&amp;value); v[i].value = value; v[i].weight = weight; v[i].pervalue = v[i].value/v[i].weight; &#125; sort(v.begin()+1,v.end(),cmp); //max int max = 0 ; max = v[1].pervalue*c; //min int min = 0 ,tmp = 0 ; for(int i = 1 ; i &lt;= v.size() ; ++i)&#123; if(tmp + v[i].weight &lt;= c)&#123; tmp += v[i].weight; min += v[i].value; &#125; else &#123;break;&#125; &#125; //main priority_queue&lt;point&gt; q; point init; init.w = 0 ,init.v = 0,init.vb = max , init.next = 1; q.push(init); double value = 0 ; while(!q.empty())&#123; point m = q.top(); q.pop(); if(value &lt; m.v) &#123;value = m.v;&#125; &#123; // cout &lt;&lt; m.v &lt;&lt;" "&lt;&lt; m.vb&lt;&lt;" "&lt;&lt;m.w&lt;&lt;" "&lt;&lt;m.next&lt;&lt;endl; &#125; if(m.next != number+1)&#123; //不加 double s = m.v + (c - m.w)*v[m.next+1].pervalue; if(s &gt;= min) &#123; point add; add.w = m.w; add.v = m.v ; add.vb = s; add.next = m.next + 1 ; q.push(add); &#125; //加 //判断是否可以加 if(m.w + v[m.next].weight &lt;= c)&#123; point add; add.w = m.w + v[m.next].weight; add.v = m.v + v[m.next].value; add.next = m.next + 1 ; add.vb = add.v + (c - add.w)*v[add.next].pervalue; if(add.vb &lt; min) &#123;continue;&#125; q.push(add); &#125; &#125; &#125; cout &lt;&lt; value; return 0;&#125; 谢谢访问]]></content>
      <categories>
        <category>算法课下实验</category>
        <category>Banch_limit_0-1pacage</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[temp]]></title>
    <url>%2F2019%2F11%2F21%2Ftemp%2F</url>
    <content type="text"><![CDATA[问题描述邮票问题 设有已知面额的邮票m种，每种有n张，问用总数不超过n张的邮票进行组合，能组合的邮票面额中可以连续的面额数最多有多少？ 例如：n=4 m=3 面额分别为：v1=1 v2=2 v3=4 最后的解为14。 请设计回溯算法求解以上问题，分析算法的时间复杂度；利用C语言实现，要求结果正确。 问题分析 首先要读懂题意：即给的邮票能组合成最大的连续数字是多少。 我们不妨假设它可以组合成连续的正无穷的数字。接下来，我们从1数字开始尝试看所给邮票能不能组合而成，显然这是一个for循环。如果一旦不能组合而成，则返回数字减1，即为最大所能组合而成的邮票最大值。 算法设计首先从文件里读出邮票种类以及其面值、可用邮票数量。 接下来，我们设置一个没有边界的循环，目的是探究最大连续数字是多少 之后利用回溯方法： 尝试每次所选的票的面值，目的是使所有票面值之和为外层假设的最大票数。 部分解：如果加入该票后，总的票的面额没有大于外层假设的最大票数。如果不是，则需要进一步循环尝试 合法解：如果在该票为部分解的前提下，总的票的面额没有大于外层假设的等于票数，此时跳出双重while的回溯算法，继续增加外层假设的最大票数面值之和。 当使用回溯法时，发现对于某个连续的最大票数面值之和没有找到合法解，则该最大票数面值之和减一即为最大连续票数面值之和。 时间复杂度： 两个while回溯循环T= O(n^n) 再加上最外层for循环T = On\^(n+1)）= O(n^n) 参考代码#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; char buffer[220]; ifstream in("Temp.txt"); int m = 0 , n = 0; in.getline(buffer,20); sscanf(buffer,"%d%d",&amp;m,&amp;n); //邮票价值从小输入 vector&lt;int&gt; v(m+1); int max_value = 0 ; for(int i = 1 ; i &lt; v.size() ; ++i)&#123; in.getline(buffer,20); int temp = 0; sscanf(buffer,"%d",&amp;temp); v[i] = temp; if(max_value &lt; temp)&#123;max_value = temp;&#125; &#125; vector&lt;int&gt; c(n+1); for(int i = 1 ; ; ++i)&#123; bool flag = false; for(int k = 1 ; k&lt;=n ; ++k)&#123; c[k] = 0 ; &#125; int k = 1 ; while(k &gt;= 1)&#123; while(c[k] &lt; max_value &amp;&amp; k&lt;= n)&#123; for(int j = 1 ; j &lt; v.size() ; ++j) &#123;if(v[j] &gt; c[k]) &#123;c[k] = v[j]; break;&#125;&#125; int sum = 0 ; for(int a = 1 ;a &lt; c.size() ; ++a) &#123;sum += c[a];&#125; //cout &lt;&lt; sum&lt;&lt;i &lt;&lt; " "; if(sum == i) &#123;flag = true ;break;&#125; else if(sum &lt; i) &#123;k += 1 ;&#125; &#125; if(flag) &#123;break;&#125; c[k] = 0 ; k -= 1 ; &#125; if(flag) &#123;continue;&#125; else &#123;--i;cout &lt;&lt; i ; break;&#125; &#125; return 0;&#125; 谢谢访问]]></content>
      <categories>
        <category>算法课下实验</category>
        <category>color</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[color]]></title>
    <url>%2F2019%2F11%2F21%2Fcolor%2F</url>
    <content type="text"><![CDATA[问题描述3-着色问题 判定无向图G=（V,E）是否可以用3种颜色着色，可以，请给出着色方案。 问题分析 处理三色问题，我们要考虑到每条边的两个端点颜色需要不同。 采用回溯的方法，对每种结果进行尝试，如果当前颜色不能满足约束条件，则换一种颜色，如果任何颜色尝试任何颜色后，都不满足约束条件，则需要向后退，k&lt;- k-1,同时把尝试颜色的点的颜色清空(c[k] = 0 ) . 如果尝试的颜色满足约束条件，则判断它是否满足解的条件，如果满足，则输出相应颜色分布。否则，则可能为部分解，接下来尝试下一个节点颜色。 算法设计首先使用按行读文件的方式，从文件获取顶点个数、边的个数以及相应的两 个顶点之间有边。 所花时间为线性时间T = O(n) 接下来初始化二维数组，若两结点没有边，则边的权值为正无穷。否则为边的文件输入的边的权所花时间T = O(n^2) 接下来为核心算法： ​ 首先构造一维数组，一维数组值为颜色，0代表没有涂颜色。 ​ 接下来开始从第一节点开始确定其颜色，通过加一向该节点涂颜色。如果涂上某颜色后，需要判断是否与其他节点颜色冲突。 判断所花时间为线性时间**T = O(n)** ​ 接下来在判断是否满足解空间。如果最后一个节点是部分解(有颜色且不与任何节点颜色冲突)，则是解空间的一个解。此判断所花时间为线性时间T = O(1)，之后直接退出双层循环即可 如果图的解空间为空，则需要两层whlie循环需要时间为O(number^color) 参考代码#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 999bool solve(vector&lt;int&gt;c)&#123; int len = c.size(); --len; if(c[len] != 0)&#123;return true;&#125; return false;&#125;bool judge( vector&lt;vector&lt;int&gt; &gt; v,int k,vector&lt;int&gt; c)&#123; for(int i = 1 ;i &lt; v.size() ; ++i)&#123; if(v[k][i] != INF)&#123; if(c[k] == c[i])&#123;return false;&#125; &#125; &#125; return true;&#125;int main()&#123; char buffer[220]; ifstream in("Three_color.txt"); int number = 0,color= 0,sidenumber = 0 ; in.getline(buffer,20); sscanf(buffer,"%d%d%d",&amp;number,&amp;color,&amp;sidenumber); vector&lt;vector&lt;int&gt; &gt; v(number+1); for(int i = 1 ; i &lt; v.size() ; ++i)&#123; v[i].resize(number+1); &#125; for(int i = 1 ; i &lt; v.size() ; ++i)&#123; for(int j = 1 ; j &lt; v[i].size(); ++j)&#123; v[i][j] = INF; &#125; &#125; for(int i = 1 ; i&lt;= sidenumber ; ++i)&#123; in.getline(buffer,20); int m = 0 , n = 0 ,w = 0; sscanf(buffer,"%d%d%d",&amp;m,&amp;n,&amp;w); v[m][n] = w ; v[n][m] = w ; &#125; vector&lt;int&gt; c(number+1); for(int k = 1 ; k &lt;= number ; ++k)&#123; c[k] = 0; &#125; int k = 1 ; bool flag = false ; while(k &gt;= 1)&#123; while(c[k] &lt;= color &amp;&amp; k &lt;= number)&#123; c[k] += 1 ; if(judge(v,k,c))&#123; if(solve(c))&#123; flag = true ; break;&#125; k += 1 ; &#125; &#125; if(flag)&#123;break;&#125; c[k] = 0 ; k -= 1 ; &#125; if(!flag)&#123;cout &lt;&lt; "no solution !" ;&#125; else&#123; for(int i = 1 ; i &lt; c.size() ; ++i) &#123;cout&lt;&lt;c[i]&lt;&lt;" ";&#125; &#125; return 0;&#125; 谢谢访问]]></content>
      <categories>
        <category>算法课下实验</category>
        <category>color</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Base TSP]]></title>
    <url>%2F2019%2F11%2F10%2FBase-TSP%2F</url>
    <content type="text"><![CDATA[问题描述已知图G=(V,E)，利用贪心策略求解图G上的从顶点1出发的最短巡回旅行路线，要求输出找到的(近似)最短巡回旅行路线。 要求：给出问题的贪心算法，并编程实现 问题分析本题类似邮递员问题，从图中任意一个出发，首先寻找起始点到所有点距离最近 的点，找到后，新的点再找离它最近的点，知道回到出发点，即位所求最短路径。这种思路显然为贪心思路。简洁总结如下： 从某个城市开始，每次选择一个城市，知道所有的城市都被走完 每次只选择到下一个城市最近的路线所对应的城市 算法设计(1) 从文件读入内存数据，时间复杂度为线性O(n) (2) 邻接矩阵储存顶点之间的边的长度。 (3) 使用双重循环，从起点开始，依次找到最短路径上的顶点： 具体思路如下： 开始时X = {起点a}，Y = {顶点b，顶点c，顶点d} 确定起点到另外三个顶点中最短的一个顶点路径，并将b号顶点加入X集合，此时X ={a,b}，Y ={c,d} 按照每次只加入离当前顶点最近的顶点，知道Y集合为空。 时间复杂度为O(n^2) 综上所述，时间复杂度为O(n^2) 参考代码#include &lt;bits/stdc++.h&gt;using namespace std;#define MAXLEN 99999int greedy(int start_city,const int number,vector&lt;int&gt;&amp;city, const vector&lt; vector&lt;int&gt; &gt; length )&#123; cout &lt;&lt; "TSP路线:" &lt;&lt; endl; //cout &lt;&lt; start_city &lt;&lt; "--&gt;"; int start = start_city ; int next_city = 0; int sum_min = 0 ; for(int i = 1 ; i &lt;= number ; ++i)&#123; int len = MAXLEN; for(int j = 1 ; j &lt;= number ; j++)&#123; if(city[j] == 1) &#123;continue;&#125; if(len &gt; length[start_city][j]) &#123; len = length[start_city][j]; next_city = j ; &#125; &#125; start_city = next_city ; cout&lt;&lt;start_city&lt;&lt;"--&gt;"; city[start_city] = 1; sum_min += len; &#125; sum_min += length[start_city][start] ; cout &lt;&lt; start &lt;&lt;endl; return sum_min;&#125;int main()&#123; char buffer[200]; int number = 0 ; //城市个数 int edge = 0 ; //边个数 vector&lt;int&gt; city(number+1); // 记录城市已经路过 ifstream in("tsp.txt"); in.getline(buffer,20); sscanf(buffer,"%d",&amp;number); // 构造二维数组 vector&lt; vector&lt;int&gt; &gt; length(number+1); for(int i = 0 ; i &lt; length.size() ; ++i)&#123;length[i].resize(number+1);&#125; //临界矩阵保存两点间路的长度 //输入两点间的路径个数 in.getline(buffer,20); sscanf(buffer,"%d",&amp;edge); //保存两点间路径长度 for(int i = 1 ; i &lt;= edge ; ++i)&#123; in.getline(buffer,20); int m = 0 , n = 0 , w = 0; sscanf(buffer,"%d%d%d",&amp;m,&amp;n,&amp;w); length[m][n] = w ; length[n][m] = w ; &#125; for(int i = 0 ; i &lt; length.size();++i)&#123; for(int j = 0 ; j &lt; length.size(); ++j)&#123; cout &lt;&lt; length[i][j] &lt;&lt;" "; &#125; cout &lt;&lt; endl; &#125; int start_city = 0 ; int sum_min = 0 ; in.getline(buffer,20); sscanf(buffer,"%d",&amp;start_city); sum_min = greedy(start_city,number,city,length); cout &lt;&lt; "最短路径长度为: " &lt;&lt; sum_min ; return 0;&#125; 谢谢访问]]></content>
      <categories>
        <category>算法课下实验</category>
        <category>activity</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[活动安排问题]]></title>
    <url>%2F2019%2F11%2F10%2F%E6%B4%BB%E5%8A%A8%E5%AE%89%E6%8E%92%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题描述设有n个活动的集合e={1，2，…，n}，其中每个活动都要求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。每个活动i都有一个要求使用该资源的起始时间si和一个结束时间fi,且si]]></content>
      <categories>
        <category>算法课下实验</category>
        <category>activity</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长公共子序列]]></title>
    <url>%2F2019%2F10%2F30%2F%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[问题描述给定两个字符串，求其最大公共子序列 问题分析 本题是典型的动态规划问题，我们将大字符串分解成小字符串进行计算。 为了节省空间，我们使用一维滚动数组求解 算法设计 找到递推入口：当len(string_first) = 0 时, 一维数组元素均为零。 当len(string_second) = 0时,一维数组元素均为零 从字符串二长度为一开始，设置二层循环，对记录的一维数组进行修改 递归公式 若str1[i] == str2[j] , 则v[j] = tmp (tmp单独保存斜上角的数) 若str1[i] != str2[j] , 则v[j] = max(v[j],v[j-1]) 总时间复杂度 = O(len(str1) *len(str2)) 约等于 O(n^2) 参考代码#include &lt;bits/stdc++.h&gt;using namespace std;int main(int argc, char const *argv[])&#123; //文件操作 ifstream in("Common_subsequence.txt"); if(!in) &#123; cout &lt;&lt; "打开文件出错" &lt;&lt; endl; return 0 ; &#125; string str1 , str2 ; getline(in,str1); getline(in,str2); int len1 = str1.size() , len2 = str2.size(); int arrays = max(len1,len2); str1 = '0' + str1; str2 = '0' + str2; vector&lt;int&gt; v(arrays+1); int row = arrays,col = 0 ; string stemp ; if(len1 &gt;= len2) &#123;col = len2; stemp = str2 ; str2 = str1; str1 = stemp ;&#125; else&#123;col = len1 ;&#125; int temp = 0 , tmp = 0 ; for(int i = 1 ; i &lt;= col ; ++i)&#123; tmp = 0 ; for(int j = 1 ; j &lt;= arrays ; ++j)&#123; temp = v[j]; if(str1[i] == str2[j])&#123;v[j] = tmp + 1;&#125; else&#123;v[j] = max(v[j-1],v[j]);&#125; tmp = temp ; &#125; //输入每一行值 for(int i = 0 ; i &lt;= arrays ; ++i)&#123;cout &lt;&lt; v[i] &lt;&lt; " ";&#125; cout&lt;&lt;endl; &#125; //输入字符串一 str1 = str1.substr(1,str1.size()-1); str2 = str2.substr(1,str2.size()-1); cout &lt;&lt; "str1: "&lt;&lt;str1&lt;&lt;endl; //输入字符串二 cout &lt;&lt; "str2: "&lt;&lt;str2&lt;&lt;endl; return 0;&#125; 谢谢访问]]></content>
      <categories>
        <category>算法课下实验</category>
        <category>Longest_common_subsequence</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[苹果树剪枝]]></title>
    <url>%2F2019%2F10%2F30%2F%E8%8B%B9%E6%9E%9C%E6%95%B0%E5%89%AA%E6%9E%9D%2F</url>
    <content type="text"><![CDATA[问题描述有一棵苹果树，如果树枝有分叉，一定是分2叉（就是说没有只有1个孩子的结点）。这棵树共有n个结点（叶子点或者树枝分叉点），编号为1~n，树根编号一定是1。 现在这棵树枝条太多了，需要剪枝。但是一些树枝上长有苹果。 给定需要保留的树枝数量P，求出最多能留住多少苹果。 要求： (1) 创建合适的数据结构存储树的信息。 (2) 设计问题的递归公式。 (3) 实现动态规划算法，输出保留的树枝数量P和最多留住的苹果数。 问题分析本题不仅涉及到动态规划的算法，还涉及到了数据结构-树。 首先，需要找一种树的存储方法，其次，为方便计算，将节点与树的枝条连在一起计算。 节点本身需要一个挂在树上的枝条，接下来是分类讨论它的左右孩子所有拥有的枝条数对应的最大苹果树。 使用一位数组存树，2i即为其左子树，2i+1即为其右子树 这类问题就是通过将大问题化解为同类小问题，找到递推入口(即从叶子节点)，并从入口向目标求解递推 算法设计： 储存树 由于题目给的是极其类似满二叉树的结构，故不使用递归的方法构造树，而采用一维数组，用少量空间换取大量时间。构造树的时间为线性时间n 初始化运算表 将每个节点所拥有一到p个枝条时最大苹果树用二位数组存放。C++构造二维数组所花线性时间为n 从子叶节点(递推入口开始)开始，对于子叶节点拥有一到p个枝条，苹果数值均为其本身苹果数。 枝条为零的情况下，所有节点所含苹果数为零 设计递推 递推方程式为 f[i][j] = max(f[i][j],f[i2][k]+f[i2+1][j-1-k]+ value[i]); 采用双重循环，求出每个节点从1到p枝条时的最大所含苹果数。所用时间n^p 得出结果 f[i] [p+1]即位整棵树最大苹果数。 总时间复杂度分析 T= t(初始化)+t(递推) = O(n^2) 参考代码#include &lt;bits/stdc++.h&gt;using namespace std;int string_to_number(string s)&#123; stringstream ss(s) ; int a = 0 ; ss &gt;&gt; a ; return a ;&#125;int main(int argc, char const *argv[])&#123; int number = 0 , p = 0 ; //文件操作一 ifstream in("apple.txt"); string line; if(!in) &#123; cout &lt;&lt; "打开文件出错" &lt;&lt; endl; return 0 ; &#125; getline(in,line); number = string_to_number(line); line.clear(); getline(in,line); p = string_to_number(line); vector&lt;int&gt; value(number+1); //文件操作二 for(int i = 1 ; i &lt; number+1 ; ++i)&#123; line.clear() ; getline(in,line); value[i] = string_to_number(line);&#125; vector&lt; vector&lt;int&gt; &gt; f(number+1); for(int i = 1 ; i &lt; number + 1 ; ++i)&#123;f[i].resize(p+2);&#125; //初始化 for(int i = 1 ; i &lt; number + 1 ; ++i)&#123;f[i][0] = 0 ; f[i][1] = value[i];&#125; for(int i = number ; i &gt;= 1; --i )&#123; for(int j = 2 ; j &lt;= p + 1 ; ++j)&#123; for(int k = 0 ; k &lt; j ; ++k)&#123; if(i*2 &lt;= number)&#123;f[i][j] = max(f[i][j],f[i*2][k]+f[i*2+1][j-1-k]+ value[i]);&#125; //没有左子树以及右子树，则该值为其本身价值 else&#123;f[i][j] = value[i] ;&#125; &#125; &#125; &#125; cout &lt;&lt; f[1][p+1]; return 0;&#125; 谢谢访问]]></content>
      <categories>
        <category>算法课下实验</category>
        <category>Apple_tree_pruning</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[背包一维数组实现]]></title>
    <url>%2F2019%2F10%2F30%2F%E8%83%8C%E5%8C%85%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[背包分类0-1背包只用考虑物品放与不放 vector&lt;int&gt; volume(c) ;for(int i = 1 ; i &lt;= n ; ++i)&#123; for(int j = c ; j &gt;=weight[i] ; j--)&#123; volume[j] = max(volume[j] , volume[j-weight[i]] + value[i]); 完全背包每种物品数量不限 for(int i = 1 ; i &lt;= n ; ++i)&#123; for(int j = weight[i] ; j &lt;= n ; ++j)&#123; f[j] = max(volume[j] , volume[j-weight[i]] + value[i]); &#125; &#125; 限制背包每种物品数量可能不止一个 for(int i=1;i&lt;=n;i++) for(int j=m;j&gt;=0;j--) for(int k=0;k&lt;=c[i];k++)&#123; if(j-k*a[i]&lt;0)break; f[j]=max(f[j],f[j-k*a[i]]+k*b[i]); &#125; 详细分析请看 算法实验之限制背包 谢谢访问]]></content>
      <categories>
        <category>算法课下实验</category>
        <category>Pacage_problem_One-dimensiona</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[背包问题]]></title>
    <url>%2F2019%2F10%2F30%2F%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题描述已知n种物品的体积、价值和数量，背包的容积为C，从物品中选择装入背包的物品，每种物品装入数量不超过物品的数量，请设计算法求出装入价值最大的装法。 要求： (1) 输入n种物品的体积、价值和数量，输入背包的容积。 (2) 分析给出带限制的整数背包问题的递归公式。 (3) 利用动态规划算法编程求解，输出每种物品装入背包的个数和装入背包的最大价值。 算法分析问题分析：这是一个有限制物品数量的背包，一个典型的动态规划问题。在这里，我们不仅要使用二维数组解出背包最大价值，还要直到放了哪个物品多少件 算法设计： 采用动态规划的方法解出此题： 部分最优则整体最优。 从背包只放入一种物品开始，每次背包容量加一，并在该容量判断背包在实现最大价值的情况下，最多可以加入该物品多少个。显然符合动态规划部分最优全局最优规则 动规递推入口 即当背包内物品种类为零时，任意容量价值均为零 当背包容量为零时，物品种类所对应价值均为零 从背包有一种物品，背包容积为最大容积开始递推。 动规方程式 v[i][j] = max(v[i][j] , v[i][j – weight[i]k] + value[i]k); 复杂度分析： 定义数组以及价值初始化 首先，定义结构体，包含物品价格以及每种物品放入价格。由于使用C++的vector结构，故省去C语言初始化线性时间n; 对存放物品个数计数的数组进行初始化，需花费n^m时间 使用三重循环，按照背包内装有几种物品、对应背包容量、放几个对应物品，对表进行递推运算，此时时间复杂度为n^3 总结：时间复杂度为O(n^3),但要比三维数组的时间复杂度以及空间复杂度小 参考代码#include &lt;bits/stdc++.h&gt;using namespace std;typedef struct&#123; int value = 0; vector&lt;int&gt; numbers ;&#125;pacage;int string_to_number(string s)&#123; stringstream ss(s) ; int a = 0 ; ss &gt;&gt; a ; return a ;&#125;//------------------------------------------------------int main(int argc, char const *argv[])&#123; ifstream in("package.txt"); int m = 0 , n = 0 ; // 背包容积、物品种类 string s ; getline(in,s); m = string_to_number(s); s.clear(); getline(in,s); n = string_to_number(s);//------------------------------------------------------ vector&lt;int&gt; value(n+1); // 每种物品的价值 vector&lt;int&gt; weight(n+1); // 每种物品一个重量 vector&lt;int&gt; number(n+1); // 每种物品数量 vector&lt; vector&lt;pacage&gt; &gt; v(n+1) ; // 物品总价值 for(int i = 0 ; i &lt;= n ; ++i)&#123;v[i].resize(m+1);&#125; for(int i = 1 ; i &lt;= n ; ++i) &#123;s.clear();getline(in,s); value[i] = string_to_number(s); &#125; for(int i = 1 ; i &lt;= n ; ++i) &#123;s.clear();getline(in,s); weight[i] = string_to_number(s); &#125; for(int i = 1 ; i &lt;= n ; ++i) &#123;s.clear();getline(in,s); number[i] = string_to_number(s); &#125;//------------------------------------------------------ //限制背包 for(int i = 0 ; i &lt;= n ; ++i)&#123; for(int j = 0; j &lt;= m ; ++j) &#123; v[i][j].numbers.resize(100);&#125; &#125; for(int i = 1 ; i &lt;= n ; ++i)&#123; for(int j = m ; j &gt;= 0 ;--j)&#123; for(int k = 0 ; k &lt;= number[i] ; ++k)&#123; if(j &lt; k*weight[i]) &#123;break;&#125; if( v[i][j].value &lt; v[i-1][j-weight[i]*k].value + value[i]*k) &#123; for(int s = 0 ; s &lt; 100 ; ++s) &#123; v[i][j].numbers[s] = v[i-1][j-weight[i]*k].numbers[s]; &#125; v[i][j].value = v[i-1][j-weight[i]*k].value + value[i]*k; v[i][j].numbers[i] = k ; &#125; &#125; &#125; &#125; cout &lt;&lt; "背包最优的价值情况"&lt;&lt;endl; cout &lt;&lt; "物品编号 物品数量 物品价值 单个物品体积"&lt;&lt;endl; for(int i = 1 ; i &lt;= n ; ++i)&#123;cout&lt;&lt;" "&lt;&lt;i&lt;&lt;" "&lt;&lt;v[n][m].numbers[i] &lt;&lt;" "&lt;&lt;value[i] &lt;&lt; " "&lt;&lt;weight[i]&lt;&lt;endl;&#125; cout &lt;&lt; "背包内物品最高价值"&lt;&lt;endl; cout &lt;&lt; v[n][m].value; return 0;&#125; 谢谢访问]]></content>
      <categories>
        <category>算法课下实验</category>
        <category>Pacage_problem</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寻找中项和第k小元素]]></title>
    <url>%2F2019%2F10%2F16%2F%E5%AF%BB%E6%89%BE%E4%B8%AD%E9%A1%B9%E5%92%8C%E7%AC%ACk%E5%B0%8F%E5%85%83%E7%B4%A0%E3%80%81%2F</url>
    <content type="text"><![CDATA[问题描述在统计学领域中，中项是一个非常关键的常用的指标值。序列的中项是指排好序后序列的“中间”元素，中项是指序列的第[n/2]个最小元素。寻找序列中项的问题被称为中项值问题，寻找序列中第k小元素的问题被称为选择问题。 要求： 元素个数n≥100。 请利用减治的思想，设计该问题的分治算法。 采用两种划分的方式：教材上的方法和随机选择的方法，并对比两种方法的性能 问题分析在平常寻找向量(数组、容器)数值第k个元素时，我们一般使用快速排序将元素按指定规则排序，则第k个元素位置即排好序的第k-1向量位置。这种方法平均时间复杂度为O(nlogn – n +1)。 这里，我们采用分治方法，降低时间复杂度为线性。 算法设计 先将数组按照每五个分为一组，剩下多余元素排去 其次将分好的数组用快排排序，时间为cn(c约等于7)，所以时间消耗为线性阶 去各分组数组的中值构成一个新数组，并求出新数组中值mm。时间消耗为线性阶 根据中值mm，将中值mm设置为基准，原数组根据mm划成三个集合A，B，C。(A中元素值小于mm,B中元素值等于mm，C中元素值大于mm) 根据如下情况进行下一步 如果A集合数字个数大于K，则返回select(A,0,high,k) 如果A + B 集合的数字个数等于K，则mm即位所求，返回mm即可 否则 select(C,0,high,k) 分治过程如下 分：将数组分按照mm为三个集合 治：判断k在哪个集合，不同集合治法不同 组合： 这里涉及到了简治，即排除不可能为所寻找元素，降低了时间复杂度 阈值：当集合值为mm时，返回mm。 参考代码#include &lt;bits/stdc++.h&gt;using namespace std;void QuickSort(vector&lt;int&gt; &amp;a, int left, int right) &#123; if(left &lt; right) &#123; int i = left, j = right, k = a[left]; //利用循环，使基准左边数字均小于基准，右边均大于基准 while (i &lt; j) &#123; while (i &lt; j &amp;&amp; a[j] &lt; k) &#123; --j; &#125; //从右向左找到第一个比基准大的数 if (i &lt; j) &#123; a[i++] = a[j]; &#125; while (i &lt; j &amp;&amp; a[i] &gt; k) &#123; ++i; &#125; //从左向右找到第一个比基准小的数 if (i &lt; j) &#123; a[j--] = a[i]; &#125; &#125; a[i] = k; QuickSort(a, left, i - 1); // 排序k左边 QuickSort(a, i + 1, right); // 排序k右边 &#125;&#125;void divide(vector&lt;int&gt;&amp;a,int &amp;numa, int &amp; numb ,const int mm)&#123; int i = 0 , j = a.size()-1 , k = mm; //利用循环，使基准左边数字均小于基准，右边均大于基准 while (i &lt; j) &#123; while (i &lt; j &amp;&amp; a[j] &lt; k) &#123; --j; &#125; //从右向左找到第一个比基准大的数 if (i &lt; j) &#123; a[i++] = a[j]; &#125; while (i &lt; j &amp;&amp; a[i] &gt; k) &#123; ++i; &#125; //从左向右找到第一个比基准小的数 if (i &lt; j) &#123; a[j--] = a[i]; &#125; &#125; a[i] = mm; for(int i = 0 ; i &lt; a.size()-1 ;++i)&#123;if(a[i] == mm)&#123;numb++;&#125;&#125; numa = i + 1 ;&#125;int Search_K_Element(vector&lt;int&gt;&amp;v,int low,int high,int k)&#123; int p = high - low + 1; if(p &lt; 44) &#123; QuickSort(v,low,high); return v[v.size() / 2]; &#125; vector&lt;int&gt; m ; int tmp = 2 , mm = 0,pos = 0; //分组并排序 int cnt = (high - low + 1)/ 5 ; int left = low ,right = low + 4 ; for(int i = 0 ; i &lt; cnt ; ++i)&#123; QuickSort(v,left,right); left += 5 ; right += 5 ; &#125; //分组中项排序 for(int i = 0 ; i &lt; cnt ; ++i)&#123; m.push_back(v[tmp]); tmp += 5 ; &#125; QuickSort(m,0,m.size()-1); if(m.size() % 2 == 0)&#123;mm = m[m.size() / 2 - 1];&#125; else &#123;mm = m[(m.size()+1) / 2 - 1];&#125; //确定mm在原数组的位置 for(int i = 0 ; i &lt; v.size()-1 ; ++i)&#123;if(v[i] == mm)&#123;pos = i ; break;&#125;&#125; //分A,B,C三个数组 int numa = 0 , numb = 0 , numc = 0; divide(v,numa,numb,mm); numc = v.size() - numa - numb ; //cout&lt;&lt;mm&lt;&lt;endl; if(numa &gt; k )&#123; Search_K_Element(v,low,numa - 1, k); &#125; else if(numa + numb &gt;= v.size() / 2 ) &#123;return mm ;&#125; else &#123; Search_K_Element(v,numa + numb,numc - 1, k - numa - numb); &#125;&#125;int main()&#123; vector&lt;int&gt; v ; cout&lt;&lt;"请输入待寻找中项数组,以r字母结束"&lt;&lt;endl; while(1) &#123; int tmp = 0 ; int r =scanf("%d",&amp;tmp); if(r == 0)&#123;break;&#125; else &#123; v.push_back(tmp);&#125; &#125; fflush(stdin); int k ; cin &gt;&gt; k ; int result = Search_K_Element(v,0,v.size()-1,k); cout&lt;&lt;result&lt;&lt;endl; for(int i = 0 ; i&lt; v.size() ; ++i) &#123;cout &lt;&lt; v[i] &lt;&lt; " ";&#125; return 0;&#125; 谢谢访问]]></content>
      <categories>
        <category>算法课下实验</category>
        <category>Search-K-Element</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大整数乘法]]></title>
    <url>%2F2019%2F10%2F16%2F%E5%A4%A7%E6%95%B4%E6%95%B0%E4%B9%98%E6%B3%95%2F</url>
    <content type="text"><![CDATA[题目描述程序设计语言中的整型数据类型可以存放一定范围内的整数，超出这个范围的大整数就不能再用普通变量存储和操作，这样的整数通常被称为“大整数”。大整数的存储需要借助于数组或链表等，其操作也需要编写程序完成。 要求： 大整数的位数n≥16，可以是十进制或者二进制数。 两个大整数相乘如果按照传统的方法，需要耗费n2次数量相乘，试设计大整数乘法的分治算法，要求时间复杂度低于n2阶。 算法分析 我们采用分治算法，具体算法如下 我们将n位的二进制整数X和Y各分为2段，每段的长为n/2位（为简单起见，假设n是2的幂），有下图形式 计算公式为 XY = (A2^(n/2)+B)(C2^(n/2)+D)=AC2^n+(AD+CB)2^(n/2)+BD 对于2的n次方，我们采用左移n位即可，需要的时间为n。另外需要四次乘法以及三次加法，这蕴含下图递推式： ​ 由数学方法我们可知该算法时间复杂度为n^2 ​ 所以采用Toom—Cook算法对上面的算法进行优化： ​ wz + xy = (w + x )(y + z) -wy – xz ​ 再结合上面的算式，我们仅计算三次乘法以及次加减 运算，此中方法的递推式如下 经计算，使用Toom—Cook算法的时间复杂度为O(n^1.59)。 分治过程如下： 分: 将两个大整数分别分成四个较小整数 治：利用Toom—Cook算法进行计算 组合: 将每次算出的结果以字符串拼接相加 阈值： 这里设置阈值为4，不再分，并将运算结果返回 直接运算 ： 当数字的位数为4时，直接计算两数乘法。 参考代码/************************************************************************///函数功能：分治法求两个N为的整数的乘积//输入参数：X,Y分别为两个N为整数//h核心优化方程 ：uv = wy2n+[(w-x)(z-y)+wy+xz]2n/2+xz//时间复杂度为：T(n)=O(nlog3)=O(n1.59)/************************************************************************/#include &lt;bits/stdc++.h&gt;using namespace std;//C++数字转字符串string number_to_string(int m)&#123; stringstream ss ; ss &lt;&lt; m ; string re ; ss &gt;&gt; re ; return re;&#125;//C++字符串转数字int string_to_number(string m)&#123; stringstream ss(m); int s ; ss &gt;&gt; s ; return s ;&#125;//在数字前面加0string same_number_zero_before(string m , int s)&#123; for(int i = 0 ; i &lt; s ; ++i)&#123;m.insert(0,"0");&#125; return m ;&#125;//在数字后面加零string same_number_zero_follow(string m , int s)&#123; for(int i = 0 ; i &lt; s ; ++i) &#123;m.insert(m.size(),"0");&#125; return m ;&#125;//两个数字相加string string_add(string a , string b)&#123; if(a.size() &gt; b.size()) &#123;b = same_number_zero_before(b,a.size() - b.size()) ;&#125; else if(b.size() &gt; a.size()) &#123;a = same_number_zero_before(a,b.size() - a.size()) ;&#125; string result; int co = 0 ; for(int i = a.size() - 1 ; i &gt;= 0 ; --i)&#123; int c = (a[i] - '0') + (b[i] - '0') + co; co = c / 10 ; c %= 10 ; result.insert(0,number_to_string(c)); &#125; if(co != 0)&#123;result.insert(0,number_to_string(co));&#125; return result ;&#125;string string_sub(string a , string b)&#123; while(a[0] == '0' &amp;&amp; a.size() &gt; 1) &#123;a = a.substr(1,a.size()-1);&#125; while(b[0] == '0' &amp;&amp; b.size() &gt; 1) &#123;b = b.substr(1,b.size()-1);&#125; if(a.size() &gt; b.size())&#123; b = same_number_zero_before(b,a.size() - b.size());&#125; string result ; for(int i = a.size() - 1 ; i &gt;= 0 ; --i)&#123; int c = (a[i] - '0') - (b[i] - '0'); if(c &lt; 0)&#123; c += 10 ; int prepos = i -1 ; char prechar = a[prepos]; while(prechar == '0') &#123; a[prepos] = '9'; prepos = -1 ; prechar = a[prepos]; &#125; a[prepos] -= 1 ; &#125; result.insert(0,number_to_string(c)); &#125; return result;&#125;//计算string数字的乘法函数string multi(string u , string v)&#123; //首先将两个数前面的0去除,保留有效的计算位数 while(u[0] == '0' &amp;&amp; u.size() &gt; 1)&#123;u = u.substr(1,u.size()-1);&#125; while(v[0] == '0' &amp;&amp; v.size() &gt; 1)&#123;v = v.substr(1,v.size()-1);&#125; int n = 4 ; if(u.size() &gt; 2 || v.size() &gt; 2) &#123; if(u.size() &gt;= v.size()) &#123; //f为2的n次方位数大小，直到f的位数与x或者y中的 最大的 一个数 位数 相同或者大 停止 while(u.size() &gt; n)&#123; n *= 2 ;&#125; if(u.size() != n) &#123; //为了计算两个数，使u,v,f三个数位数相同 u = same_number_zero_before(u,n-u.size()); v = same_number_zero_before(v,n-v.size()); &#125; &#125; else &#123; //f为2的n次方大小，直到f的位数比x或者y中的最大的一个数位数大停止 while(v.size() &gt; n)&#123; n *= 2 ;&#125; if(v.size() != n) &#123; //为了计算两个数，使u,v,f三个数位数相同 u = same_number_zero_before(u,n-u.size()); v = same_number_zero_before(v,n-v.size()); &#125; &#125; &#125; //时刻保证u以及v有两位 if(u.size() == 1 )&#123;u = same_number_zero_before(u,1);&#125; if(v.size() == 1 )&#123;v = same_number_zero_before(v,1);&#125; //时刻保证u、v位数相同 if(u.size() &gt; v.size())&#123;v = same_number_zero_before(v,u.size() - v.size());&#125; if(u.size() &lt; v.size())&#123;u = same_number_zero_before(u,v.size() - u.size());&#125; //确定两数的位数 int num = u.size(); //分割u,v string w , x , y , z ; if(num &gt; 1)&#123; w = u.substr(0, num / 2 ); x = u.substr(num/2 , num - 1); y = v.substr(0, num / 2); z = v.substr(num / 2 , num - 1); &#125; string result ; //循环阈值为2，结束递归，回迭 if(num == 2 )&#123; int nw = string_to_number(w); int nx = string_to_number(x); int ny = string_to_number(y); int nz = string_to_number(z); result = number_to_string((nw*10 + nx)*(ny*10 +nz)); &#125; else &#123; string c1 = multi(w,y); string c2 = multi(x,z); string c11 = string_add(w,x); string c22 = string_add(y,z); string c33 = multi(c11,c22); string c44 = string_add(c1,c2); string c55 = string_sub(c33,c44); string ss1 = same_number_zero_follow(c55,num/ 2); string ss2 = same_number_zero_follow(c1 , num ); result = string_add(string_add(ss2,ss1),c2); &#125; return result;&#125;int main(int argc, char const *argv[])&#123; bool flag = true ; //循环计算多组大数乘法 while(flag) &#123; string u , v ; int sign = 0 ,sign1 = 0, sign2 = 0 ; //程序使用提示 cout&lt;&lt;"大整数 - 分治法 - C++版 - O(n^1.53)" &lt;&lt; endl ; //输入第一个数 cout&lt;&lt;"请输入第一个数"&lt;&lt;endl; bool inputfunction = true; while(inputfunction) &#123; cin&gt;&gt;u; int f = 0 ; for(int i = 1 ; i &lt; u.size() ; ++i) &#123; if(u[i] &lt; '0' || u[i] &gt; '9')&#123;cout&lt;&lt;"输入数据非法，请重新输入"&lt;&lt;endl;f = 1 ;break;&#125; &#125; if(f == 0)&#123;break;&#125; &#125; //输入第二个数 cout &lt;&lt; "请输入第二个数"&lt;&lt; endl; while(inputfunction) &#123; cin &gt;&gt; v; int f = 0 ; for(int i = 1 ; i &lt; v.size() ; ++i) &#123; if(v[i] &lt; '0' || v[i] &gt; '9')&#123;cout&lt;&lt;"输入数据非法，请重新输入"&lt;&lt;endl; f = 1 ;break;&#125; &#125; if(f == 0)&#123;break;&#125; &#125; //取出各个数字的符号位 if(u[0] != '-')&#123;sign1 = 1 ;&#125; else&#123;sign1 = -1;u = u.substr(1,u.size()-1);&#125; if(v[0] != '-')&#123;sign2 = 1 ;&#125; else&#123;sign2 = -1;v = v.substr(1,v.size()-1);&#125; //求出两数相乘符号位 sign = sign1 * sign2 ; //计算两个数的abs乘积值,并以string输出 string result = multi(u,v); while('0' == result[0] &amp;&amp; result.size() &gt; 1) &#123; result = result.substr(1,result.size() - 1); &#125; cout &lt;&lt; "结果："&lt;&lt;endl; if(sign == -1) &#123;cout&lt;&lt;'-';&#125; cout &lt;&lt; result &lt;&lt; endl; cout&lt;&lt;"继续请输入1，否则输入任意字符"&lt;&lt;endl; string s ; cin &gt;&gt; s ; if(s.size() == 1 &amp;&amp; s[0] == '1') &#123;continue;&#125; else &#123;break;&#125; &#125;&#125; 谢谢访问]]></content>
      <categories>
        <category>算法课下实验</category>
        <category>Big-number-Multiple</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序]]></title>
    <url>%2F2019%2F09%2F15%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 算法描述 比较相邻的元素。如果第一个比第二个大，就交换它们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数； 针对所有的元素重复以上的步骤，除了最后一个； 重复步骤1~3，直到排序完成。 算法图解 算法分析最好情况：数组已满足要求排序顺序，此时只需要n-1比较 最坏情况：数组与要求排序顺序刚好相反。此时比较次数 1/2(n^2 - n)次，需要赋值次数3/2(n^2-n)次 综合，时间复杂度为O(n^2) 参考代码void Bubble_Sort(int a[], int N)&#123; int i = 0, j = 0, flag = 0; for (i = 0; i &lt; N; ++i) &#123; for (j = 0; j &lt; N - i; ++j) &#123; int temp = 0; if (a[j + 1] &lt; a[j]) &#123; temp = a[j + 1]; a[j + 1] = a[j]; a[j] = temp; flag = 1; &#125; &#125; if (flag) &#123; break; &#125; &#125;&#125; 谢谢访问]]></content>
      <categories>
        <category>排序</category>
        <category>Bubble_Sort</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[旋转数组]]></title>
    <url>%2F2019%2F09%2F15%2F%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目描述给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 示例一输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4] 示例二输入: [-1,-100,3,99] 和 k = 2输出: [3,99,-1,-100]解释: 向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100] 说明 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。 要求使用空间复杂度为 O(1) 的 原地 算法。 题目分析由名思义，此题用到旋转方法。 我们不妨以[1,2,3,4,5,6,7] 和 k = 3为例，首先[1,2,3,4]反转为[4,3,2,1]；其次，将[5,6,7]反转为[7,6,5];之后对整个数组进行反转，得到结果[5,6,7,1,2,3,4]; 我们发现归并排序的归并函数(Merge())，如果也想让空间复杂度为O(1)，用的也是这种旋转方法 最后，就是处理好一些极端情况：例如数组长度为0，直接返回；如果，k大于数组长度，则右移次数为为 len % k ，即 k - len。 参考代码class Solution &#123;public: void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; int len = nums.size(); if(len &lt;= 1 || k &lt; 1 )&#123;return;&#125; if (k &gt; len) &#123; k = k % len;&#125;// 处理 k 大于 数组长度的情况 int i = len-k; reverse(nums.begin(),nums.begin()+i); reverse(nums.begin()+i,nums.end()); reverse(nums.begin(),nums.end()); &#125;&#125;; 谢谢访问]]></content>
      <categories>
        <category>LeetcodeDateBase</category>
        <category>Double Point</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2F2019%2F09%2F14%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[快速排序快速排序是在一般情况下时间复杂度为O(nlogn)的排序。 基本思想通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 算法图解 算法分析时间复杂度 当情况为最优时(即基准每一次都在数组中央)，则 比较次数（每一次都比较n次）为： T(n) &lt;= 2*T(n/2)+n T(n) &lt;= 2(2(T(n/4) + n / 2) + n = 4T(n/4) + 2n …… T(n) &lt;= nT(1) + nlog2n = O(nlogn) 但情况最糟糕时 比较次数 = (n - 1) + (n - 2 ) + … + 2 + 1 = n(n-1) / 2 ; O(n^2) 参考代码void QuickSort(int a[] , int left , int right)&#123; int i = left , j = right , k = a[left]; //利用循环，使基准左边数字均小于基准，右边均大于基准 while(i &lt; j)&#123; while(i &lt; j &amp;&amp; a[j] &lt; k) &#123;--j;&#125; //从右向左找到第一个比基准大的数 if(i &lt; j) &#123;a[i++] = a[j] ;&#125; while(i &lt; j &amp;&amp; a[i] &gt; k) &#123;++i;&#125; //从左向右找到第一个比基准大】小的数 if(i &lt; j) &#123;a[j--] = a[i] ;&#125; &#125; a[i] = k ; // 递归调用 QuickSort(a, left, i - 1); // 排序k左边 QuickSort(a, i + 1, right); // 排序k右边&#125; 谢谢访问]]></content>
      <categories>
        <category>排序</category>
        <category>Quick_Sort</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移除元素]]></title>
    <url>%2F2019%2F09%2F14%2F%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[题目描述给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例一给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。 示例二给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 说明为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 题目分析我们采用双指针方式，一个为快指针，用于迭代；一个为慢指针，用于将不为val的数向前移 参考代码class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; if(nums.empty())return 0; int i = 0; for(int k = 0 ; k &lt; nums.size();k++)&#123; if(nums[k]!=val)nums[i++]=nums[k]; &#125; return i; &#125;&#125;; 谢谢访问]]></content>
      <categories>
        <category>LeetcodeDateBase</category>
        <category>Double Point</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[长度最小的子数组]]></title>
    <url>%2F2019%2F09%2F14%2F%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目描述给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。 示例一输入: s = 7, nums = [2,3,1,2,4,3]输出: 2解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。 题目分析首先将从首元素开始，对数字进行累加，直到sum大于s，然后从start 开始减去截取子数组的元素，直到sum比s小。 参考代码class Solution &#123;public: int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(),sum = 0,j = INT_MAX,start = 0; if(len == 0 &amp;&amp; s != 0) &#123;return 0 ;&#125; if(len == 0 &amp;&amp; s == 0) &#123;return 1 ;&#125; for(int i = 0 ; i &lt; len ; ++i) &#123; sum += nums[i]; while(sum &gt;= s)&#123; j = min(j,i - start + 1); sum -= nums[start++]; &#125; &#125; return j != INT_MAX ? j : 0 ; &#125;&#125;; 谢谢访问]]></content>
      <categories>
        <category>LeetcodeDateBase</category>
        <category>Double Point</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读者反馈]]></title>
    <url>%2F2019%2F09%2F14%2F%E8%AF%BB%E8%80%85%E5%8F%8D%E9%A6%88%2F</url>
    <content type="text"><![CDATA[读者反馈当文章过长时，来比力无法正常加载，所以及大家在这里提出意见以及建议]]></content>
      <categories>
        <category>读者反馈</category>
      </categories>
      <tags>
        <tag>查找不足</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[输入有序数组]]></title>
    <url>%2F2019%2F09%2F14%2F%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目描述给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例输入: numbers = [2, 7, 11, 15], target = 9输出: [1,2]解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 分析设两个指针，一个指向数组的起点，一个指向数组的末尾。如果start + end &gt; target ,则end—，若start + end &lt; target ,则start++。直到找到或者start == end 结束。 参考代码class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; vector&lt;int&gt;::iterator t = numbers.end() -1 ; vector&lt;int&gt;::iterator i = numbers.begin(); vector&lt;int&gt; ans; while(1) &#123; if(target == *t+*i) &#123; ans.push_back(i-numbers.begin() +1); ans.push_back(t-numbers.begin() +1); return ans; &#125; if(target &gt; *t+*i) &#123; i++; &#125; else &#123; t--; &#125; &#125; &#125;&#125;; 谢谢访问]]></content>
      <categories>
        <category>LeetcodeDateBase</category>
        <category>Double Point</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[螺旋矩阵]]></title>
    <url>%2F2019%2F09%2F13%2F%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[题目描述给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。 示例一输入:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]输出: [1,2,3,6,9,8,7,4,5] 示例二输入:[ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12]]输出: [1,2,3,4,8,12,11,10,9,5,6,7] 思路逐层遍历，请参看代码 参考代码class Solution &#123;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if (matrix.empty() || matrix[0].empty()) return &#123;&#125;; int m = matrix.size(), n = matrix[0].size(); vector&lt;int&gt; res; int up = 0, down = m - 1, left = 0, right = n - 1; while (true) &#123; for (int j = left; j &lt;= right; ++j) res.push_back(matrix[up][j]); if (++up &gt; down) break; for (int i = up; i &lt;= down; ++i) res.push_back(matrix[i][right]); if (--right &lt; left) break; for (int j = right; j &gt;= left; --j) res.push_back(matrix[down][j]); if (--down &lt; up) break; for (int i = down; i &gt;= up; --i) res.push_back(matrix[i][left]); if (++left &gt; right) break; &#125; return res; &#125;&#125;; 谢谢访问]]></content>
      <categories>
        <category>LeetcodeDateBase</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对角线遍历]]></title>
    <url>%2F2019%2F09%2F13%2F%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[题目表述给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。 示例输入:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]输出: [1,2,4,7,5,3,6,8,9]解释: 说明：给定矩阵中的元素总数不会超过 100000 。 题目分析 观察对角线遍历是右上、左下型移动 每次相加应为{x轴加一，y轴减一}，或者{x轴减一，y轴加一} 当x轴溢出时，则x轴为row-1，y轴加二 当y轴溢出时，则y轴为col-1 ， x轴加二 当x轴小于0时，则x轴为0，y轴加一 当y轴小于0时，则y轴为0，x轴加一 参考代码class Solution &#123;public: vector&lt;int&gt; findDiagonalOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if (matrix.empty() || matrix[0].empty()) return &#123;&#125;; int m = matrix.size(), n = matrix[0].size(), r = 0, c = 0, k = 0; vector&lt;int&gt; res(m * n); vector&lt;vector&lt;int&gt;&gt; dirs&#123;&#123;-1,1&#125;, &#123;1,-1&#125;&#125;; for (int i = 0; i &lt; m * n; ++i) &#123; res[i] = matrix[r][c]; r += dirs[k][0]; c += dirs[k][1]; if (r &gt;= m) &#123;r = m - 1; c += 2; k = 1 - k;&#125; if (c &gt;= n) &#123;c = n - 1; r += 2; k = 1 - k;&#125; if (r &lt; 0) &#123;r = 0; k = 1 - k;&#125; if (c &lt; 0) &#123;c = 0; k = 1 - k;&#125; &#125; return res; &#125;&#125;; 总结 首先考虑非特殊(本题为非矩阵角处)的规律 在考虑特殊情况 谢谢访问]]></content>
      <categories>
        <category>LeetcodeDateBase</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加一]]></title>
    <url>%2F2019%2F09%2F13%2F%E5%8A%A0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[题目描述给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例一输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。 示例二输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字 4321。 题目分析 注意单纯的相加问题，如109，加一则为110. 注意进位问题。如果原来是99，则加一之后为100。 参考代码class Solution &#123;public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123; int k = 10 ,sum = 0, co = 0 , len = digits.size() -1; for(int i = len ; i &gt;= 0 ; --i) &#123; if(i == digits.size()-1) &#123;digits[i] = digits[i] + 1 + co ; co = 0 ;&#125; else &#123;digits[i] += co ; co = 0 ;&#125; int tmp = digits[i] ; if(tmp &gt;= 10) &#123;digits[i] -= 10 ; co = 1 ;&#125; if(i == 0 &amp;&amp; co == 1 ) &#123;digits.insert(digits.begin(),1);&#125; &#125; return digits; &#125;&#125;; 谢谢访问]]></content>
      <categories>
        <category>LeetcodeDateBase</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寻找数组的中心索引]]></title>
    <url>%2F2019%2F09%2F13%2F%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[题目描述给定一个整数类型的数组 nums，请编写一个能够返回数组“中心索引”的方法。 我们是这样定义数组中心索引的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。 如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。 示例一输入: nums = [1, 7, 3, 6, 5, 6]输出: 3解释: 索引3 (nums[3] = 6) 的左侧数之和(1 + 7 + 3 = 11)，与右侧数之和(5 + 6 = 11)相等。同时, 3 也是第一个符合要求的中心索引。 示例二输入: nums = [1, 2, 3]输出: -1解释: 数组中不存在满足此条件的中心索引。 说明 nums 的长度范围为 [0, 10000]。 任何一个 nums[i] 将会是一个范围在 [-1000, 1000]的整数。 题目分析思路一（延迟2000ms+） 思路迭代数组，判断每一个数左边数之和是否等于右边数之和 需要一个大循环套两个小循环，时间复杂度以及空间复杂度较高 注意当数组元素为一、为二时等特殊情况,注意竞赛时多次提交会罚时！ 思路二（延迟28ms+） 首先直接计算所有数组元素之和 之后从数组下标为零开始，依次减去该数组元素值，累加到之前减去的数值，并判断被减去后的值是否等于减数的值 该方法不用考虑什么特殊情况 参考代码思路一class Solution &#123;public: int pivotIndex(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); //当数组长度为一时，0一定时中心索引 if(len == 1) return 0 ; //当数组长度为二且第二个元素为0时，0一定是中心索引，否则一定不存在中心索引 if(len == 2)&#123; if(nums[1] == 0) &#123;return 0;&#125; else &#123;return -1 ;&#125; &#125; for(int i = 0; i &lt; len ; i++) &#123; int left = 0 , right = accumulate(nums.begin() + i + 1 , nums.end(),0); if(i == 0) &#123;left = 0;&#125; else &#123;left = accumulate(nums.begin() , nums.begin()+i,0);&#125; if(left == right) &#123;return i ;&#125; &#125; return - 1; &#125;&#125;; 思路二class Solution &#123;public: int pivotIndex(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(),i = 0 , tatal = 0 ,left = 0; for (i=0;i&lt;size;i++) &#123;total += nums[i];&#125; for (i=0;i&lt;size;i++) &#123; if (total-nums[i] == 2*left) &#123;return i;&#125; left += nums[i]; &#125; return -1; &#125;&#125;; 总结竞赛题需要思考，涉及问题等价转换(及建模)。如果按照题目要求按部就班的做，一般时复杂繁琐的或者无法用过的。 谢谢访问]]></content>
      <categories>
        <category>LeetcodeDateBase</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组和字符串总结]]></title>
    <url>%2F2019%2F09%2F13%2F%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[数组简介数组是一种基本的数据结构，用于按顺序存储元素的集合。但是元素可以随机存取，因为数组中的每个元素都可以通过数组索引来识别。]]></content>
      <categories>
        <category>LeetcodeDateBase</category>
        <category>Summary</category>
        <category>Array&amp;&amp;String</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[队列与栈学习总结]]></title>
    <url>%2F2019%2F09%2F01%2F%E9%98%9F%E5%88%97%E4%B8%8E%E6%A0%88%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[数据结构队列基本队列 结构特点：元素先进先出。 关联算法：BFS 相关题目：图论、字符串相关问题 基本队列实现方法（链表法） 队列ADT typedef struct&#123; QElement data; struct QNode * next;&#125;QNode,*QueuePtr;typedef struct&#123; QueuePtr front ; QueuePtr rear ;&#125;LinkQueue; 初始化队列 Status InitQueue(LinkQueue q)&#123; Q.front = Q.rear = (QueuePtr)malloc(sizeof(QNode)); if(!Q.front) exit(OVERFLOW); Q.front-&gt;next = nullptr; return OK;&#125; 销毁队列 Status DestroyQueue(LinkQueue &amp;Q)&#123; while(Q.front) &#123; Q.rear = Q.front-&gt;next; free(Q.front); Q.front = Q.rear; &#125;&#125; 向队列添加元素 Status EnQueue(LinkQueue &amp; Q ,QElement e)&#123; p = (QueuePtr)malloc(sizeof(QNode)); if(!P) exit(OVERFLOW); p-&gt;data = e ; p-&gt;next = nullptr; Q.rear-&gt;next = p ; Q.rear = p; return OK;&#125; 取出一个元素，并将其在队列中删除 Status DeQueue(LinkQueue &amp;Q ,QElement &amp;e)&#123; if(Q.front == Q.rear) return ERROR; p = Q.front-&gt;next; e = Q.front-&gt;data; Q.front-&gt;next = p-&gt;next; if(Q.rear == p) Q.rear = Q.front; free(p); return OK;&#125; 循环队列特点：循环利用空间，减少空间浪费 循环队列实现方法 初始化 /** Initialize your data structure here. Set the size of the queue to be k. */ MyCircularQueue(int k) &#123; data = new int[k]; head = 0; tail = 0; len = k; count = 0;&#125; 向队列插入元素 /** Insert an element into the circular queue. Return true if the operation is successful. */bool enQueue(int value) &#123; if (isFull()) //循环队列满 &#123; return false; &#125; else // 插入元素到队尾，队尾索引值增一，元素个数增一 &#123; data[tail] = value; count++; tail = (tail + 1) % len; return true; &#125;&#125; 从队列中取出元素 /** Get the front item from the queue. */int Front()&#123; if (isEmpty()) //循环队列空 &#123; return -1; &#125; else &#123; return data[head]; &#125;&#125; 删除队列头元素 /** Delete an element from the circular queue. Return true if the operation is successful. */bool deQueue()&#123; if (isEmpty()) //循环队列空 &#123; return false; &#125; else // 队头索引值增一，元素个数减一 &#123; head = (head + 1) % len; count--; return true; &#125;&#125; 取出队尾元素 int Rear() &#123;if (isEmpty()) //循环队列空 &#123; return -1; &#125;// 队尾元素位于队尾索引值减一的位置，但若队尾循环到索引 0 的位置，队尾元素位于数组最后else &#123; int temp = tail == 0 ? (len-1) : (tail-1); return data[temp]; &#125;&#125; 判断队列是否为空 /** Checks whether the circular queue is empty or not. */bool isEmpty()&#123; return count == 0; // 队列元素个数为零，队列空&#125; 判断队列是否已满 /** Checks whether the circular queue is full or not. */bool isFull()&#123; return count == len; // 队列元素个数为数组最大长度，队列满&#125; C++队列使用方法#include &lt;queue&gt; #include &lt;cstdio&gt; using namespace std; int main(int argc, char const *argv[]) &#123; queue&lt;int&gt; q ; //定义一个队列 q.push(23); //入队 q.size(); //返回队列大小 q.empty(); //判断队列为空 q.font(); //读取队头以及队尾元素 q.back(); q.pop(); //删除队首元素 return 0; &#125; 队列竞赛题参考01矩阵 图像渲染 岛屿数量 未完待续谢谢访问]]></content>
      <categories>
        <category>LeetcodeDateBase</category>
        <category>Summary</category>
        <category>Queue&amp;&amp;Stack</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01矩阵]]></title>
    <url>%2F2019%2F08%2F31%2F01%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[题目描述给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。 两个相邻元素间的距离为 1 。 示例1输入:0 0 00 1 00 0 0输出:0 0 00 1 00 0 0 示例2输入:0 0 00 1 01 1 1输出:0 0 00 1 01 2 1 注意事项 给定矩阵的元素个数不超过 10000。 给定矩阵中至少有一个元素是 0。 矩阵中的元素只在四个方向上相邻: 上、下、左、右。 分析 这道题所有为0的点都是起点。 然后开始BFS遍历，从queue中取出一个数字，遍历其周围四个点，如果越界或者周围点的值小于等于当前值加1，则直接跳过。 因为周围点的距离更小的话，就没有更新的必要，否则将周围点的值更新为当前值加1，然后把周围点的坐标加入queue参考代码class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int m = matrix.size(), n = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; dirs&#123;&#123;0,-1&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;1,0&#125;&#125;; queue&lt;pair&lt;int, int&gt;&gt; q; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (matrix[i][j] == 0) q.push(&#123;i, j&#125;); else matrix[i][j] = INT_MAX; &#125; &#125; while (!q.empty()) &#123; auto t = q.front(); q.pop(); for (auto dir : dirs) &#123; int x = t.first + dir[0], y = t.second + dir[1]; if (x &lt; 0 || x &gt;= m || y &lt; 0 || y &gt;= n || matrix[x][y] &lt;= matrix[t.first][t.second] + 1) continue; matrix[x][y] = matrix[t.first][t.second] + 1; q.push(&#123;x, y&#125;); &#125; &#125; return matrix; &#125;&#125;; 谢谢访问]]></content>
      <categories>
        <category>LeetcodeDateBase</category>
        <category>Queue</category>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像渲染]]></title>
    <url>%2F2019%2F08%2F31%2F%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[题目描述有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。 给你一个坐标 (sr, sc) 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 newColor，让你重新上色这幅图像。 为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。 最后返回经过上色渲染后的图像。 示例输入: image = [[1,1,1],[1,1,0],[1,0,1]]sr = 1, sc = 1, newColor = 2输出: [[2,2,2],[2,2,0],[2,0,1]]解析: 在图像的正中间，(坐标(sr,sc)=(1,1)),在路径上所有符合条件的像素点的颜色都被更改成2。注意，右下角的像素没有更改为2，因为它不是在上下左右四个方向上与初始点相连的像素点。 分析这是一道简单的队列BFS题 注意，两个点不仅要相邻，而且要初始像素相同 如果以前的颜色与新的颜色一样，就不用改变，直接返回old 本题示例描述不清(自认为),看看参考代码会更好理解 参考代码class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; floodFill(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr, int sc, int newColor) &#123; int row = image.size(); int col = image[0].size(); vector&lt;pair&lt;int,int&gt;&gt; directions = &#123; &#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125; &#125;; queue&lt;pair&lt;int,int&gt;&gt; q ; int old = image[sr][sc]; if(image[sr][sc] == newColor) &#123; return image; &#125; //BFS q.push(&#123;sr,sc&#125;); while(!q.empty()) &#123; int len = q.size(); while(len--) &#123; pair&lt;int,int&gt; olds = q.front(); int rows = olds.first; int cols = olds.second; q.pop(); image[rows][cols] = newColor; for(int i = 0 ; i &lt; 4 ; ++i) &#123; int tempr = rows + directions[i].first; int tempc = cols + directions[i].second; if(tempr &gt;= 0 &amp;&amp; tempr &lt; image.size() &amp;&amp; tempc &gt;= 0 &amp;&amp; tempc &lt; image[0].size() &amp;&amp; image[tempr][tempc] != newColor &amp;&amp; image[tempr][tempc] == old) &#123; q.push(&#123;tempr,tempc&#125;); &#125; &#125; &#125; &#125; return image ; &#125;&#125;; 谢谢访问]]></content>
      <categories>
        <category>LeetcodeDateBase</category>
        <category>Queue</category>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[岛屿数量]]></title>
    <url>%2F2019%2F08%2F31%2F%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F%2F</url>
    <content type="text"><![CDATA[题目描述给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。 示例1输入:11110110101100000000输出: 1 示例2输入:11000110000010000011输出: 3 分析 思路: 找到一个陆地，通过利用队列，将其相连的陆地都变成海洋。 实现: 设置双层循环，找到一个陆地，加入队列，通过队列不断将与其相连的陆地变成海洋。在队列循环外，每遍历完一块陆地，计数器值就加一参考代码class Solution &#123;public: int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123; int row = grid.size(); if(row == 0)&#123;return 0 ;&#125; int col = grid[0].size(); int cnt = 0; for(int i = 0 ; i &lt; row ; ++i) &#123; for(int j = 0 ; j &lt; col ; ++j) &#123; if(grid[i][j] == &apos;1&apos;) &#123; ++cnt; grid[i][j] = &apos;0&apos;; queue&lt;pair&lt;int,int&gt;&gt; q ; q.push(&#123;i,j&#125;); while(!q.empty()) &#123; auto s = q.front(); q.pop(); int rows = s.first ; int cols = s.second; if(rows + 1 &lt; row &amp;&amp; grid[rows + 1][cols] == &apos;1&apos;) &#123; q.push(&#123;rows+1,cols&#125;); grid[rows+1][cols] = &apos;0&apos;; &#125; if( cols +1 &lt; col &amp;&amp; grid[rows][cols+1] == &apos;1&apos;) &#123; q.push(&#123;rows,cols+1&#125;); grid[rows][cols+1] = &apos;0&apos;; &#125; if(rows - 1 &gt;= 0 &amp;&amp; grid[rows-1][cols] == &apos;1&apos;) &#123; q.push(&#123;rows-1,cols&#125;); grid[rows-1][cols] = &apos;0&apos;; &#125; if(cols-1&gt;= 0 &amp;&amp; grid[rows][cols-1] == &apos;1&apos;) &#123; q.push(&#123;rows,cols-1&#125;); grid[rows][cols-1] = &apos;0&apos;; &#125; &#125; &#125; &#125; &#125; return cnt; &#125;&#125;; 谢谢访问]]></content>
      <categories>
        <category>LeetcodeDateBase</category>
        <category>Queue</category>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[完全平方数]]></title>
    <url>%2F2019%2F08%2F30%2F%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 示例1输入: n = 12输出: 3 解释: 12 = 4 + 4 + 4. 示例2输入: n = 13输出: 2解释: 13 = 4 + 9. 分析 采用队列BFS，第一次(相当于第一层)，依次对分别对root减去1，4，9… (减数要小于root) 判断减完后的结果是否为0，如果不是，加入队列中。如果是，则返回层数。 取出队列中的元素，进行再一轮(层)减法，然后判断。重复步骤二，直到结束。 画图类似与一个多叉树。 参考代码class Solution &#123;public: int numSquares(int n) &#123; queue &lt;int&gt; q ; vector&lt;bool&gt; exit(n,false) ; int temp = n ; for(int i = 0 ,j = 1 ; j*j &lt;= temp ;++i ,++j) &#123; if(temp - j*j == 0) &#123; return 1 ; &#125; q.push(temp-j*j); exit[temp-j*j] = true ; &#125; int step = 1 ; while(!q.empty()) &#123; int len = q.size(); for(int i = 0 ; i &lt; len ; ++i) &#123; int num = q.front(); q.pop(); for(int i = 0 , j = 1 ; j*j &lt;= num ; ++i,++j) &#123; if(num - j*j == 0) &#123; return ++step; &#125; // 避免队列里有重复数字 if(exit[num-j*j] == false) &#123;q.push(num-j*j);&#125; &#125; &#125; ++step; &#125; return step; &#125;&#125;; 谢谢访问]]></content>
      <categories>
        <category>LeetcodeDateBase</category>
        <category>Queue</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打开键盘的锁]]></title>
    <url>%2F2019%2F08%2F30%2F%E6%89%93%E5%BC%80%E9%94%AE%E7%9B%98%E7%9A%84%E9%94%81%2F</url>
    <content type="text"><![CDATA[题目描述 你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’ 。每个拨轮可以自由旋转：例如把 ‘9’ 变为 ‘0’，’0’ 变为 ‘9’ 。每次旋转都只能旋转一个拨轮的一位数字。 锁的初始数字为 ‘0000’ ，一个代表四个拨轮的数字的字符串。列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。 字符串 target 代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1 示例1输入：deadends = [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target = &quot;0202&quot;输出：6解释：可能的移动序列为 &quot;0000&quot; -&gt; &quot;1000&quot; -&gt; &quot;1100&quot; -&gt; &quot;1200&quot; -&gt; &quot;1201&quot; -&gt; &quot;1202&quot; -&gt; &quot;0202&quot;。注意 &quot;0000&quot; -&gt; &quot;0001&quot; -&gt; &quot;0002&quot; -&gt; &quot;0102&quot; -&gt; &quot;0202&quot; 这样的序列是不能解锁的，因为当拨动到 &quot;0102&quot; 时这个锁就会被锁定。 示例2输入: deadends = [&quot;8888&quot;], target = &quot;0009&quot;输出：1解释：把最后一位反向旋转一次即可 &quot;0000&quot; -&gt; &quot;0009&quot;。 示例3输入: deadends = [&quot;8887&quot;,&quot;8889&quot;,&quot;8878&quot;,&quot;8898&quot;,&quot;8788&quot;,&quot;8988&quot;,&quot;7888&quot;,&quot;9888&quot;], target = &quot;8888&quot;输出：-1解释：无法旋转到目标数字且不被锁定。 示例4输入: deadends = [&quot;0000&quot;], target = &quot;8888&quot;输出：-1 分析 通过观察我们得知，每一个数可以通过对其位数进行加减，得到16个相邻的数pow(2,4) 这16个数中，如果都不是目标数，则如果不是dead数，就放入队列中，继续重复步骤1和2 采用unorder_set，即哈希map数据结构存放已经遍历的锁的情况，因为该数据结构在检索中是最快的 如果一直没有一种情况可以到达target，则必然跳出while(!q.empty())循环，返回-1即可。 参考代码class Solution &#123;public: int openLock(vector&lt;string&gt;&amp; deadends, string target) &#123; const string start = &quot;0000&quot;; unordered_set&lt;string&gt; dead(deadends.begin(),deadends.end()); if(dead.count(start)) return -1; if(start == target) return 0 ; int steps = 0 ; queue&lt;string&gt; q; unordered_set &lt;string&gt; visited&#123;start&#125;; q.push(start); while(!q.empty()) &#123; ++steps; const int size = q.size(); for(int i = 0 ; i &lt; size ; ++i) &#123; const string curr = q.front(); q.pop(); for(int i = 0 ; i&lt;4 ; ++i) &#123; for(int j = -1 ; j &lt;= 1 ; j+=2) &#123; string next = curr ; next[i] = (next[i] - &apos;0&apos; + j + 10) % 10 + &apos;0&apos;; if(next == target) return steps; if(dead.count(next) || visited.count(next))&#123;continue;&#125; visited.insert(next); q.push(next); &#125; &#125; &#125; &#125; return -1 ; &#125;&#125;; 谢谢访问]]></content>
      <categories>
        <category>LeetcodeDateBase</category>
        <category>Queue</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文献讲座报告]]></title>
    <url>%2F2019%2F08%2F26%2F%E6%96%87%E7%8C%AE%E8%AE%B2%E5%BA%A7%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[搜索方法搜索方法分为八个步骤 分析问题，确定你要搜索的内容选择适当的搜索工具 Google Bing Baidu 提取检索词，简化搜索范围构造检索式 如果在某一指定网站上搜索，使用如下格式 关键字+site+:+网站url效果如下 搜索关键字文件格式，关键字+空格+filetype+空格+格式(如pdf，word等等)，效果如下 如果你无法使用外网搜索引擎，可以使用如下格式去除广告 关键字+空格-广告-推广(特别是针对百度) 进行检索这里以河北地质大学图书馆为例河北地质大学图书馆我们在读者服务栏中点击“书刊目录查询”，接下来，我们再点击网页栏中的分类浏览，这样就可以根据自己的需求，寻找相应图书，效果如下 我们看到命中数有33947，如果只进行关键字搜索，可能就只有几本书。 筛选检索内容我们通过对论文引用次数进行排序，选择引用率高的，绝大多数情况下是比较好的论文 调整检索策略如果搜索的内容不尽人意，我们可以通过换关键字等方法，提高搜索效率 寻找高质量期刊以及下载方法高质量期刊搜索网站 国内 中国知网 万方数据 国外 springer sciencedirect google scholar 下载方法 国内如果你们学校没有买知网等帐号的话，那么你只能自己花钱买了2333~目前没有这里没有什么方法 国外 对于springer以及sciencedirect网站的期刊，我们可以通过在google商店(当然一可以在这里，不过网页版经常会很慢emmmmm，sci-hub,网页版不做过多介绍)里安装sci-hub插件，然后复制每一篇期刊的dos码或者示例如下首先复制文章dos码，如下图 之后打开sci-hub插件，如下图 插件会自动识别粘贴板的dos码，然后按左边的save就可以直接下载啦 对于有些朋友无法使用外网，可以现在百度下载谷歌浏览器，然后在谷歌商店安装以下插件，一切就ok啦,按照顺序安装 (首先安装chrome浏览器)(1)谷歌访问助手1(2)谷歌访问助手2(3) 谷歌学术(4)sci-hub 大功告成，再也不怕查不到东西喽 ~///(^v^)\\~ 谢谢访问]]></content>
      <categories>
        <category>论文与搜索方法</category>
      </categories>
      <tags>
        <tag>论文</tag>
        <tag>讲座</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字三角形]]></title>
    <url>%2F2019%2F08%2F23%2F%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[题目描述 图1显示了一个数字三角形。编写一个程序，计算从顶部开始到底部某处的路径上传递的最大数字总和。每个步骤可以沿对角线向下滑动，也可以沿斜向下滑动到右侧。 输入您的程序是从标准输入读取。第一行包含一个整数N：三角形中的行数。以下N行描述了三角形的数据。三角形中的行数大于 1但小于等于 100.三角形中的数字全部为整数，介于0到99之间。 输出你的程序是写入标准输出。最高总和写为整数。 输入样例573 88 1 0 2 7 4 44 5 2 6 5 输出样例30 分析分析1通过分析输入样式，我们观察到，一个数去加的下一行对应的列以及下一行j+1列。故这道题可以用递归求解? 递归参数:一个数的横纵坐标 约束条件:当函数行数等于最大行数N代码如下 #include &lt;bits/stdc++.h&gt;using namespace std;//递归程序const int M = 1000;int d[M+10][M+10];int n = 0 ;int maxs(int i , int j)&#123; if(i == n) &#123; return d[i][j]; &#125; else &#123; int a = maxs(i+1,j); int b = maxs(i+i,j+1); if(a &gt; b)&#123; return a + d[i][j];&#125; else &#123; return b + d[i][j];&#125; &#125;&#125;int main() &#123; int n = 0 ; cin &gt;&gt; n ; for(int i = 0 ; i &lt; n ; ++i) for(int j = 0 ; j &lt; i ; ++j) &#123; cin &gt;&gt; d[i][j]; &#125; cout&lt;&lt;maxs(1,1); return 0;&#125; 答案是否定的，因为你会发现从第三行开始，中间的因为递归，全部被重复计算多次，如果当数字三角型足够大时，题目肯定超时。 分析2分析1的递归显然是不能用了。但我们设一个二维数组，将算过的值保存起来，避免二次或多次计算。以下是记忆型动规的代码 const int M = 1000;int d[M+10][M+10];int n = 0 ;int Max_Array[M+10][M+10];int maxs(int i , int j)&#123; if(i == n ) &#123; return d[i][j]; &#125; else &#123; if(Max_Array[i+1][j] == -1 )&#123;Max_Array[i+1][j] = maxs(i+1,j);&#125; if(Max_Array[i+1][j+1] == -1)&#123;Max_Array[i+1][j+1] = maxs(i+1,j+1);&#125; if(Max_Array[i+1][j] &gt; Max_Array[i+1][j+1]) &#123; return Max_Array[i+1][j] + d[i][j];&#125; else&#123; return Max_Array[i+1][j+1] + d[i][j];&#125; &#125;&#125;int main() &#123; int n = 0 ; cin &gt;&gt; n ; for(int i = 0 ; i &lt; n ; ++i) for(int j = 0 ; j &lt; i ; ++j) &#123; cin &gt;&gt; d[i][j]; Max_Array[i][j] = - 1; &#125; cout &lt;&lt; maxs(1,1); return 0;&#125; 分析3分析2有效地解决了超时的问题，但开出了过多的空间。通过观察我们不难发现，第r行可以由r+1行算出。比如说，第四行的第一个数的最大路径值，等于第五行它的同列与第五行同列+1列的最大值加这个第四行的数的值。而且当第四行第一个数被算出后，第五行第一个数就没用了。这时我们可以让第四行第一行值覆盖第五行第一个值。 这就是滚动数组，对二维数组进行降维。这种动规方法为递推式动规，即用已知的值计算出未知的值。参考代码如下const int M = 1000;int d[M+10][M+10];int n = 0 ;int Maxs[M+10];int main() &#123; int n = 0 ; cin &gt;&gt; n ; //input for(int i = 0 ; i &lt; n ; ++i) for(int j = 0 ; j &lt; i ; ++j) &#123; cin &gt;&gt; d[i][j]; &#125; //init status for(int i = 0 ; i &lt; n ; ++i)&#123;Maxs[i] = d[n][i];&#125; //start for(int i = n-2 ; i &lt;=0 ; ++i) &#123; for(int j = 0 ; j &lt; i ; ++j) &#123; Maxs[i] = max(d[i][j] + Maxs[i] , d[i][j]+ Maxs[i+1]); &#125; &#125; cout &lt;&lt; Maxs[0]; return 0;&#125; 谢谢访问]]></content>
      <categories>
        <category>算法学习与竞赛</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆波兰表达式求值]]></title>
    <url>%2F2019%2F08%2F21%2F%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目描述根据逆波兰表示法，求表达式的值。有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。说明： 整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。 示例1输入: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]输出: 9解释: ((2 + 1) * 3) = 9 示例2输入: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]输出: 6解释: (4 + (13 / 5)) = 6 示例3输入: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]输出: 22解释: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5= ((10 * (6 / (12 * -11))) + 17) + 5= ((10 * (6 / -132)) + 17) + 5= ((10 * 0) + 17) + 5= (0 + 17) + 5= 17 + 5= 22 分析我们可以发现，一个符号要操作两个数，一定在符号的左边，所以用栈解决最简单 参考代码class Solution &#123;public: int change(string m) &#123; stringstream ss ; ss &lt;&lt; m ; int a ; ss &gt;&gt; a ; return a ; &#125; int evalRPN(vector&lt;string&gt;&amp; tokens) &#123; int len = tokens.size(),ans= 0 ; stack&lt;int&gt; q; if(tokens[0] != &quot;*&quot; &amp;&amp; tokens[0] != &quot;/&quot; &amp;&amp; tokens[0] != &quot;+&quot; &amp;&amp; tokens[0] != &quot;-&quot;)&#123;q.push(change(tokens[0]));&#125; for(int i = 0; i &lt; len ; ++i) &#123; if(tokens[i] &gt;= &quot;0&quot; &amp;&amp; tokens[i] &lt;= &quot;9&quot;) &#123; q.push(change(tokens[i])); &#125; else &#123; int a = q.top(); q.pop(); int b = q.top(); q.pop(); if(tokens[i] == &quot;*&quot;) &#123;ans = a*b ; q.push(ans);&#125; if(tokens[i] == &quot;/&quot;) &#123;ans = a/b ; q.push(ans);&#125; if(tokens[i] == &quot;+&quot;) &#123;ans = a+b ; q.push(ans);&#125; if(tokens[i] == &quot;-&quot;) &#123;ans = a-b ; q.push(ans);&#125; &#125; &#125; return ans ; &#125;&#125;; 谢谢访问]]></content>
      <categories>
        <category>LeetcodeDateBase</category>
        <category>Stack</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有效的括号]]></title>
    <url>%2F2019%2F08%2F21%2F%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[题目表述给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例1输入: &quot;()&quot;输出: true 示例2输入: &quot;()[]&#123;&#125;&quot;输出: true 示例3输入: &quot;(]&quot;输出: false 示例4输入: &quot;([)]&quot;输出: false 分析这是一道典型的栈结构的题，因为它体现了LIFO特性 思路一 首先要先往栈里放一个元素 紧着利用for循环，比较接下来的字符是否可以栈顶元素匹配成一对括号，如果不可以，则将其也压如栈中；如果可以，就将栈顶元素出栈 当for循环结束时，如果栈不为空，则输出false，否则输出true 思路二 构造两个栈，左括号放入栈一，右括号放入栈二 当放入结束后，开始同时从两个栈取出元素，如果有一对不匹配，则返回false 当两个栈全为空时，依旧没有return，则返回true 参考代码(这里只提供思路一)class Solution &#123;public: bool isValid(string s) &#123; stack&lt;char&gt; result; int n=s.size(); if(n==0) return true; for(int i=0;i&lt;n;i++) &#123; if(result.empty()) result.push(s[i]); else if(result.top()==&apos;(&apos;&amp;&amp;s[i]==&apos;)&apos;|| result.top()==&apos;[&apos;&amp;&amp;s[i]==&apos;]&apos;|| result.top()==&apos;&#123;&apos;&amp;&amp;s[i]==&apos;&#125;&apos;) result.pop(); else result.push(s[i]); &#125; return result.empty(); &#125;&#125;; 谢谢访问]]></content>
      <categories>
        <category>LeetcodeDateBase</category>
        <category>Stack</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1162. 地图分析]]></title>
    <url>%2F2019%2F08%2F20%2F%E5%9C%B0%E5%9B%BE%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[题目描述你现在手里有一份大小为 N x N 的『地图』（网格） grid，上面的每个『区域』（单元格）都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地，你知道距离陆地区域最远的海洋区域是是哪一个吗？请返回该海洋区域到离它最近的陆地区域的距离。 我们这里说的距离是『曼哈顿距离』（ Manhattan Distance）：(x0, y0) 和 (x1, y1) 这两个区域之间的距离是 |x0 - x1| + |y0 - y1| 。如果我们的地图上只有陆地或者海洋，请返回 -1。 示例1 输入：[[1,0,1],[0,0,0],[1,0,1]]输出：2解释： 海洋区域 (1, 1) 和所有陆地区域之间的距离都达到最大，最大距离为 2。 示例2 输入：[[1,0,0],[0,0,0],[0,0,0]]输出：4解释： 海洋区域 (2, 2) 和所有陆地区域之间的距离都达到最大，最大距离为 4。 提示 1 &lt;= grid.length == grid[0].length &lt;= 100 grid[i][j] 不是 0 就是 1 分析这也是一道队列的题目，恰好和我曾经数据结构实验的迷宫类似首先，将原本grid[i][j] = 1的(陆地)全部入队。其次我们从一个陆地出发，寻找从上下左右寻找grid[i][j] = 0的地方，第一次循环(循环的结束标志为上一次加入队列的元素未处理个数)，将一部分海洋变成陆地，即grid[i][j] = 1。之后为cnt++，即走一步距离。重复上面的动作，知道queue没有元素。此时返回cnt即为所求。 参考代码class Solution &#123;public: const int directions[5] = &#123;0, 1, 0, -1, 0&#125;; int maxDistance(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int ret = 0; int N = grid.size(); queue&lt;pair&lt;int, int&gt;&gt; q; // 将陆地(值为 1)的点入队 for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; N; j++) &#123; if (grid[i][j] == 1) &#123; q.push(&#123;i, j&#125;); &#125; &#125; &#125; // 全是海洋或全是陆地 if (q.size() == 0 || q.size() == N * N) return -1; while (!q.empty()) &#123; int s = q.size(); int r = 0; while (s != 0) &#123; pair&lt;int, int&gt; front = q.front(); q.pop(); // 4 个方向遍历 for (int i = 0; i &lt; 4; i++) &#123; int nx = front.first + directions[i]; int ny = front.second + directions[i + 1]; if (nx &gt;= N || ny &gt;= N || nx &lt; 0 || ny &lt; 0 || grid[nx][ny] == 1) continue; r++; // 这里没有新开二位数组做记录，而是直接在原数组上做标记 grid[nx][ny] = 1; q.push(&#123;nx, ny&#125;); &#125; s--; &#125; if (r &gt; 0) ret++; &#125; return ret; &#125;&#125;; 谢谢访问]]></content>
      <categories>
        <category>Leetcode单周赛</category>
        <category>week150</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1161. 最大层内元素和]]></title>
    <url>%2F2019%2F08%2F20%2F%E6%9C%80%E5%A4%A7%E5%B1%82%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目描述给你一个二叉树的根节点 root。设根节点位于二叉树的第 1 层，而根节点的子节点位于第 2 层，依此类推。请你找出层内元素之和 最大 的那几层（可能只有一层）的层号，并返回其中 最小 的那个。 示例 输入：[1,7,0,7,-8,null,null]输出：2解释：第 1 层各元素之和为 1，第 2 层各元素之和为 7 + 0 = 7，第 3 层各元素之和为 7 + -8 = -1，所以我们返回第 2 层的层号，它的层内元素之和最大。 分析这是一个典型的树与BFS综合题。通过计算树的每一层节点之和，方可回答此题。此题涉及到了队列的BFS。队列的作用是不仅要用于计算出当前层的节点值的和，还要保存本层节点孩子的地址。通过while()循环，算出一层的值。 参考代码class Solution &#123;public: int maxLevelSum(TreeNode* root) &#123; if(root == nullptr) &#123;return 0;&#125; // int maxlevel = 1 , curlevel = 1 , summax = 1 ; queue&lt;TreeNode*&gt; q ; q.push(root); while(!q.empty()) &#123; int s = q.size(); int cursum = 0; while(s) &#123; TreeNode* font = q.front(); q.pop(); if(font-&gt;left != nullptr)&#123;q.push(font-&gt;left);&#125; if(font-&gt;right != nullptr)&#123;q.push(font-&gt;right);&#125; cursum += font-&gt;val; --s; &#125; if(cursum &gt; summax)&#123;maxlevel = curlevel ; summax = cursum ; &#125; ++curlevel; &#125; return maxlevel; &#125;&#125;; 谢谢访问]]></content>
      <categories>
        <category>Leetcode单周赛</category>
        <category>week150</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1160. 拼写单词]]></title>
    <url>%2F2019%2F08%2F20%2F%E6%8B%BC%E5%86%99%E5%8D%95%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[题目描述给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。注意：每次拼写时，chars 中的每个字母都只能用一次。返回词汇表 words 中你掌握的所有单词的 长度之和。 实例1输入：words = [&quot;cat&quot;,&quot;bt&quot;,&quot;hat&quot;,&quot;tree&quot;], chars = &quot;atach&quot;输出：6解释： 可以形成字符串 &quot;cat&quot; 和 &quot;hat&quot;，所以答案是 3 + 3 = 6 实例2输入：words = [&quot;hello&quot;,&quot;world&quot;,&quot;leetcode&quot;], chars = &quot;welldonehoneyr&quot;输出：10解释：可以形成字符串 &quot;hello&quot; 和 &quot;world&quot;，所以答案是 5 + 5 = 10。 分析此题涉及到字符匹配，是一般的字符匹配题，难度很小。通过调用string的find方法，同时定义一个temp字符串，放到for循环里，每一次循环都更新为chars。for循环里的循环次数为words中的字符串个数。在每一次更新中，利用find()函数对words[i]中的每一个字符进行寻找，若找不到，直接continue，否则就使temp对应的字符变成’-1’(题目里事先说只有小写字母)。最后，如果word[i]中的字符都可以由chars提供，则令cnt+words[i].length()；循环结束后，直接返回出cnt值就行啦。 参考代码class Solution &#123;public: int countCharacters(vector&lt;string&gt;&amp; words, string chars) &#123; int len = words.size(); int num = 0; for(int i = 0 ; i &lt; len ; ++i) &#123; string temp = chars; int cnt = 0,flag = 0 ; for(int j = 0 ; j &lt; words[i].size() ; ++j) &#123; if(temp.find(words[i][j]) == string :: npos) &#123; flag = 0 ; break; &#125; else &#123; int s = temp.find(words[i][j]); temp[s] = &apos;-1&apos;; flag = 1; &#125; &#125; if(flag == 1)&#123;num+=words[i].length();&#125; &#125; return num ; &#125;&#125;; 谢谢访问]]></content>
      <categories>
        <category>Leetcode单周赛</category>
        <category>week150</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[739. 每日温度]]></title>
    <url>%2F2019%2F08%2F20%2F%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[题目描述根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。 输入数据[73,74,75,71,69,72,76,73] 期望数据[1,1,4,2,1,1,0,0] 分析此种找到一个数大的值的第一个数问题，就是明摆着告诉你要用到单调栈其实使用两次循环也可以，但是复杂度高，容易答题失败 什么是单调栈就是一个栈，里面的元素的大小按照他们所在栈内的位置，满足一定的单调性 本题如何利用单调栈维护一个单调递减的stack，stack内部存的是原数组的每个index。每当我们遇到一个比当前栈顶所对应的数大的数的时候，我们就遇到了一个“大数“。这个”大数“比它之前多少个数大我们不知道，但是至少比当前栈顶所对应的数大。我们弹出栈内所有对应数比这个数小的栈内元素，并更新它们在返回数组中对应位置的值。因为这个栈本身的单调性，当我们栈顶元素所对应的数比这个元素大的时候，我们可以保证，栈内所有元素都比这个元素大。对于每一个元素，当它出栈的时候，说明它遇到了自己的next greater element，我们也就要更新redult数组中的对应位置的值。如果一个元素一直不曾出栈，那么说明不存在next greater element，我们也就不用更新result数组了。参考代码class Solution &#123;public: vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) &#123; vector&lt;int&gt; result(T.size(),0); stack&lt;int&gt; q; for(int i = 0 ; i &lt; T.size() ; ++i) &#123; while(!q.empty()&amp;&amp;T[q.top()] &lt; T[i]) &#123; result[q.top()] = i - q.top(); q.pop(); &#125; q.push(i); &#125; return result; &#125;&#125;; 谢谢访问]]></content>
      <categories>
        <category>LeetcodeDateBase</category>
        <category>Stack</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1061 判断题 (15 分)]]></title>
    <url>%2F2019%2F08%2F18%2F%E5%88%A4%E6%96%AD%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目描述判断题的评判很简单，本题就要求你写个简单的程序帮助老师判题并统计学生们判断题的得分。 输入格式输入在第一行给出两个不超过 100 的正整数 N 和 M，分别是学生人数和判断题数量。第二行给出 M 个不超过 5 的正整数，是每道题的满分值。第三行给出每道题对应的正确答案，0 代表“非”，1 代表“是”。随后 N 行，每行给出一个学生的解答。数字间均以空格分隔。 输出格式按照输入的顺序输出每个学生的得分，每个分数占一行。 输入样例3 62 1 3 3 4 50 0 1 0 1 10 1 1 0 0 11 0 1 0 1 01 1 0 0 1 1 输出样例131112 分析此题过于简单，必为乙级第一题。用三个vector容器分别保存题目正解、题目满分以及学生得分。为避免超时，在输入学生作答结果同时进行判分，将分数保存在stu[i]里。 参考代码#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; stu(101) , num(101),score(101);int main() &#123; int n , m; cin &gt;&gt; n &gt;&gt; m ; for(int i = 0; i &lt; m ; ++i)&#123;cin &gt;&gt; score[i];&#125; for(int i = 0 ; i &lt; m; ++i)&#123;cin &gt;&gt; num[i] ;&#125; for(int i = 0 ; i&lt;n ; ++i) &#123; for(int j = 0 ; j &lt; m ; ++j) &#123; int temp = 0 ; cin &gt;&gt; temp ; if(temp == num[j]) &#123; stu[i] +=score[j]; &#125; &#125; &#125; for(int i = 0 ; i &lt; n ; ++i)&#123;cout&lt;&lt;stu[i]&lt;&lt;endl;&#125; return 0;&#125; 谢谢访问]]></content>
      <categories>
        <category>PAT</category>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1062 最简分数 (20 分)]]></title>
    <url>%2F2019%2F08%2F18%2F%E6%9C%80%E7%AE%80%E5%88%86%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述一个分数一般写成两个整数相除的形式：N/M，其中 M 不为0。最简分数是指分子和分母没有公约数的分数表示形式。现给定两个不相等的正分数 N1/M​1和N2/M2，要求你按从小到大的顺序列出它们之间分母为 K 的最简分数 输入格式输入在一行中按 N/M 的格式给出两个正分数，随后是一个正整数分母 K，其间以空格分隔。题目保证给出的所有整数都不超过 1000。 输出格式在一行中按 N/M 的格式列出两个给定分数之间分母为 K 的所有最简分数，按从小到大的顺序，其间以 1 个空格分隔。行首尾不得有多余空格。题目保证至少有 1 个输出。 分析 注意读题，是两个分数之间的以k为分母且最简的分数。 题目有意降低难度，即在题目中告知我们要用最大公约数知识数学——最大公约数与最小公倍数最大公约数 最大公因数，也称最大公约数、最大公因子，指两个或多个整数共有约数中最大的一个。 如果数a能被数b整除，a就叫做b的倍数，b就叫做a的约数。约数和倍数都表示一个整数与另一个整数的关系，不能单独存在。如只能说16是某数的倍数，2是某数的约数，而不能孤立地说16是倍数，2是约数。 最小公倍数 两个或多个整数公有的倍数叫做它们的公倍数，其中除0以外最小的一个公倍数就叫做这几个整数的最小公倍数。 设a,b分别为两个数，ab = a和b的最大公约数 a和b的最小公倍数 参考代码#include &lt;bits/stdc++.h&gt;using namespace std;int GCD(int a,int b)&#123; return a%b?GCD(b,a%b):b;&#125;int main() &#123; int n1, m1, n2, m2, k; int *p, *q; scanf(&quot;%d/%d %d/%d %d&quot;, &amp;n1, &amp;m1, &amp;n2, &amp;m2, &amp;k); //qujian if(n1*m2 &gt; n2 *m1) &#123; int a ,b ; a = n1 ; b = m1 ; n1 = n2 ; m1 = m2 ; n2 = a ; m2 = b ; &#125; int cnt = 0 ; for(int i = 1 ; i*m2 &lt; k*n2 ; ++i) &#123; if( i * m1 &lt;= k*n1) &#123; continue; &#125; if(GCD(k,i) != 1) &#123; continue; &#125; if(i * m1 &gt; k*n1) &#123; ++cnt; &#125; if(cnt &gt; 1) &#123; cout&lt;&lt;&quot; &quot;; &#125; printf(&quot;%d/%d&quot;,i,k); &#125; return 0;&#125; 谢谢访问]]></content>
      <categories>
        <category>PAT</category>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1063 计算谱半径 (20 分)]]></title>
    <url>%2F2019%2F08%2F18%2F%E8%AE%A1%E7%AE%97%E8%B0%B1%E5%8D%8A%E5%BE%84%2F</url>
    <content type="text"><![CDATA[题目描述在数学中，矩阵的“谱半径”是指其特征值的模集合的上确界。换言之，对于给定的 n 个复数空间的特征值 { a1+b1 i,⋯,an+bni }，它们的模为实部与虚部的平方和的开方，而“谱半径”就是最大模。现在给定一些复数空间的特征值，请你计算并输出这些特征值的谱半径。 输入格式输入第一行给出正整数 N（≤ 10 000）是输入的特征值的个数。随后 N 行，每行给出 1 个特征值的实部和虚部，其间以空格分隔。注意：题目保证实部和虚部均为绝对值不超过 1000 的整数。 输出格式在一行中输出谱半径，四舍五入保留小数点后 2 位。 输入样例50 12 0-1 03 30 -3 输出样例4.24``` ### 分析本题极为简单，但让仍然要注意，对于浮点数计算，用double不用float，用最原始的计算方法，尽量不要调用函数。 我刚开始使用了pow()函数，结果有一个测试用例无法通过### 参考代码 include using namespace std ;int main() { int n = 0 ; cin &gt;&gt; n ; float max = 0.00; for(int i = 0 ; i &lt; n ; ++i) { float a,b ,temp; scanf(“%f%f”,&amp;a,&amp;b); temp = sqrt(aa + bb); max = temp &gt; max ? temp : max; } printf(“%0.2f”,max); return 0;}``` 谢谢访问]]></content>
      <categories>
        <category>PAT</category>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1064 朋友数 (20 分)]]></title>
    <url>%2F2019%2F08%2F18%2F%E6%9C%8B%E5%8F%8B%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述如果两个整数各位数字的和是一样的，则被称为是“朋友数”，而那个公共的和就是它们的“朋友证号”。例如 123 和 51 就是朋友数，因为 1+2+3 = 5+1 = 6，而 6 就是它们的朋友证号。给定一些整数，要求你统计一下它们中有多少个不同的朋友证号。 输入格式输入第一行给出正整数 N。随后一行给出 N 个正整数，数字间以空格分隔。题目保证所有数字小于10的4次方。 输出样例首先第一行输出给定数字中不同的朋友证号的个数；随后一行按递增顺序输出这些朋友证号，数字间隔一个空格，且行末不得有多余空格。 输入样例8123 899 51 998 27 33 36 12 输出样例43 6 9 26 分析此题实质就是给出多个数，求出他们各个位数之和，重复的和算做一个数。当时我还以为至少有两个或两个以上相同的和数才算是朋友数，看来是多虑了。 参考代码#include &lt;bits/stdc++.h&gt;using namespace std;typedef struct&#123; int num = 0 ; bool flag = false ;&#125;stu;int cmp(stu a ,stu b)&#123; return a.num &gt; b.num;&#125;stu s[10000];int main() &#123; int num ,cnt = 0 ,cnts = 0; cin &gt;&gt; num ; for(int i = 0 ; i &lt; num ; ++i) &#123; string m ; cin &gt;&gt; m ; int temp = 0 ; for(unsigned int j = 0 ; j &lt; m.length() ;++j) &#123; temp = temp + m[j] - &apos;0&apos;; &#125; if(s[temp].num == 0) &#123; s[temp].num = temp ; cnt++; &#125; &#125; cout&lt;&lt;cnt&lt;&lt;endl; sort(s,s+10000,cmp); int falh = 0 ; int i = cnt - 1; while(i &gt;= 0) &#123; if(falh != 0) &#123; cout&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;s[i].num; ++falh; i--; &#125; return 0;&#125; 谢谢访问]]></content>
      <categories>
        <category>PAT</category>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1065 单身狗 (25 分)]]></title>
    <url>%2F2019%2F08%2F17%2F%E5%8D%95%E8%BA%AB%E7%8B%97%2F</url>
    <content type="text"><![CDATA[题目描述“单身狗”是中文对于单身人士的一种爱称。本题请你从上万人的大型派对中找出落单的客人，以便给予特殊关爱。 输入格式输入第一行给出一个正整数 N（≤ 50 000），是已知夫妻/伴侣的对数；随后 N 行，每行给出一对夫妻/伴侣——为方便起见，每人对应一个 ID 号，为 5 位数字（从 00000 到 99999），ID 间以空格分隔；之后给出一个正整数 M（≤ 10 000），为参加派对的总人数；随后一行给出这 M 位客人的 ID，以空格分隔。题目保证无人重婚或脚踩两条船。 输出格式首先第一行输出落单客人的总人数；随后第二行按 ID 递增顺序列出落单的客人。ID 间用 1 个空格分隔，行的首尾不得有多余空格 输入样例311111 2222233333 4444455555 66666755555 44444 10000 88888 22222 11111 23333 输出样例510000 23333 44444 55555 88888 题目分析 利用vector初始化数组，使数组下标11111的值为22222，数组下标为22222的值为11111，记录有多个有效数组个数cnt 再利用sort()函数，对数组值进行从大到小排序 从cnt-1到0，遍历输出单身狗，实现从小到大输出 利用%05d输出对应格式 参考代码#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; m(100001);vector&lt;int&gt; mm(100001);vector&lt;int&gt; p(100001);bool cmp (int a , int b)&#123; return a &gt; b;&#125;int main() &#123; int num , number; cin &gt;&gt; num ; for(int i = 0 ; i &lt; num ; ++i) &#123; int temp = 0 ; cin &gt;&gt; temp ; cin &gt;&gt; m[temp] ; m[m[temp]] = temp ; &#125; cin &gt;&gt; number ; for(int i = 0 ; i &lt; number ; ++i) &#123; cin &gt;&gt; mm[i] ; &#125; int cnt = 0 ; for(int i = 0 ; i &lt; number ; ++i) &#123; int value = m[mm[i]] ; bool flag = true; for(int j = 0 ; j &lt; number ; j++) &#123; if(value == mm[j]) &#123; flag = false; break; &#125; &#125; if(flag) &#123; p[cnt++] = mm[i]; &#125; &#125; sort(p.begin(),p.end(),cmp); if(cnt == 0) &#123; cout &lt;&lt; cnt; return 0 ; &#125; cout &lt;&lt; cnt &lt;&lt; endl; for(int i = cnt - 1 ; i &gt;= 0; --i) &#123; if(i &lt; cnt - 1) &#123; printf(&quot; &quot;); &#125; printf(&quot;%05d&quot;,p[i]); &#125; return 0;&#125; 谢谢访问]]></content>
      <categories>
        <category>PAT</category>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1066 图像过滤 (15 分)]]></title>
    <url>%2F2019%2F08%2F17%2F%E5%9B%BE%E5%83%8F%E8%BF%87%E6%BB%A4%2F</url>
    <content type="text"><![CDATA[题目描述图像过滤是把图像中不重要的像素都染成背景色，使得重要部分被凸显出来。现给定一幅黑白图像，要求你将灰度值位于某指定区间内的所有像素颜色都用一种指定的颜色替换。 输入格式输入在第一行给出一幅图像的分辨率，即两个正整数 M 和 N（0&lt;M,N≤500），另外是待过滤的灰度值区间端点 A 和 B（0≤A&lt;B≤255）、以及指定的替换灰度值。随后 M 行，每行给出 N 个像素点的灰度值，其间以空格分隔。所有灰度值都在 [0, 255] 区间内。 输出格式输出按要求过滤后的图像。即输出 M 行，每行 N 个像素灰度值，每个灰度值占 3 位（例如黑色要显示为 000），其间以一个空格分隔。行首尾不得有多余空格。 输入样例3 5 100 150 03 189 254 101 119150 233 151 99 10088 123 149 0 255 输出样例003 189 254 000 000000 233 151 099 000088 000 000 000 255 题目分析这道题非常简单，在输入过程中及对数字进行修改(降低时间啦)，在区间内的灰度值直接改为替换颜色。注意:用scanf()和printf()完成输入输出，cin或cout会超时哦再者就是注意输出格式哦，003可用%03d格式输出哈 参考代码#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int m , n ,a,b,replace; scanf(&quot;%d %d %d %d %d&quot;,&amp;m,&amp;n,&amp;a,&amp;b,&amp;replace); int s[505][505]; for(int i = 0 ; i &lt; m ; ++i) &#123; for(int j = 0 ; j &lt; n ;++j) &#123; int temp = 0 ; scanf(&quot;%d&quot;,&amp;temp); s[i][j] = temp; if(temp &gt;= a &amp;&amp; temp &lt;= b) &#123; s[i][j] = replace ; &#125; if(j &gt; 0) &#123; printf(&quot; &quot;); &#125; printf(&quot;%03d&quot;,s[i][j]); &#125; printf(&quot;\n&quot;); &#125; return 0;&#125; 谢谢访问]]></content>
      <categories>
        <category>PAT</category>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1067 试密码 (20分)]]></title>
    <url>%2F2019%2F08%2F17%2F%E8%AF%95%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[题目描述当你试图登录某个系统却忘了密码时，系统一般只会允许你尝试有限多次，当超出允许次数时，账号就会被锁死。本题就请你实现这个小功能。 输入格式输入在第一行给出一个密码（长度不超过 20 的、不包含空格、Tab、回车的非空字符串）和一个正整数 N（≤ 10），分别是正确的密码和系统允许尝试的次数。随后每行给出一个以回车结束的非空字符串，是用户尝试输入的密码。输入保证至少有一次尝试。当读到一行只有单个 # 字符时，输入结束，并且这一行不是用户的输入。 输出格式对用户的每个输入，如果是正确的密码且尝试次数不超过 N，则在一行中输出 Welcome in，并结束程序；如果是错误的，则在一行中按格式输出 Wrong password: 用户输入的错误密码；当错误尝试达到 N 次时，再输出一行 Account locked，并结束程序。 输入样例 1：Correct%pw 3correct%pwCorrect@PWwhatisthepassword!Correct%pw# 输出样例1Wrong password: correct%pwWrong password: Correct@PWWrong password: whatisthepassword!Account locked 输入样例2cool@gplt 3coolman@gpltcoollady@gpltcool@gplttry again# 输出样例2Wrong password: coolman@gpltWrong password: coollady@gpltWelcome in 分析 当输入为正确时，直接输出Welcome in 当用户输入单个#时，直接结束程序 注意如果尝试次数已经达到上线并且输入错误，要输出Wrong password:+id，以及Account locked 两句话 避免使用char数组！ 我的错误在输入字符串(string 类型)时，我没有家getchar()函数，以及getline()函数，导致两个两个测试用例一直是错的 参考代码#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; string password; int n = 0 ,cnt = 0; cin &gt;&gt; password ; cin &gt;&gt; n ;getchar(); //敲黑板 while(true) &#123; string temp ; cin &gt;&gt; n ;getchar(); //敲黑板 getline(cin,temp); if(temp == &quot;#&quot;) &#123; break; &#125; cnt++; if(temp == password &amp;&amp; cnt &lt;= n) &#123; cout &lt;&lt;&quot;Welcome in&quot;; break; &#125; else if(temp != password &amp;&amp; cnt &lt;= n) &#123; cout &lt;&lt;&quot;Wrong password: &quot;&lt;&lt;temp&lt;&lt;endl; if(cnt == n) &#123; cout&lt;&lt;&quot;Account locked&quot;; break; &#125; &#125; &#125; return 0;&#125; 谢谢访问]]></content>
      <categories>
        <category>PAT</category>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++与竞赛]]></title>
    <url>%2F2019%2F08%2F12%2Fc-%E4%B8%8E%E7%AB%9E%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[Why C++ 很多好用函数如reverse()、sort()函数等 C++标准STL、string类等功能大大降低C语言编写代码的代价 C++输入与输出C++的cin用于输入、cout用于输出，但时间比scanf()、printf()高。当使用C++string类时，需要使用cin与cout C++头文件建议一般别写万能头文件，因为有时会因万能头文件而超时#include &lt;bits/stdc++.h&gt; // 万能头文件#include &lt;cmath&gt; // 相当于C语⾔⾥⾯的#include &lt;math.h&gt;#include &lt;cstdio&gt; // 相当于C语⾔⾥⾯的#include &lt;stdio.h&gt;#include &lt;cctype&gt; // 相当于C语⾔⾥⾯的#include &lt;ctype.h&gt;#include &lt;cstring&gt; // 相当于C语⾔⾥⾯的#include &lt;string.h#include &lt;vector&gt; #include &lt;string.h&gt; C++的string使用 无法用scanf()以及printf()处理 string s = &quot;hello world&quot;; // 赋值字符串string s2 = s;string s3 = s + s2; // 字符串拼接直接⽤+号就可以string s4;cin &gt;&gt; s4; // 读⼊字符串cout &lt;&lt; s; // 输出字符串 string空格结束或回车输入，如果字符串中有空格，请用getline() string s; // 定义⼀个空字符串sgetline(cin, s); // 读取⼀⾏的字符串，包括空格cout &lt;&lt; s.length(); // 输出字符串s的⻓度 string其他功能 string 中还有个很常⽤的函数叫做 substr ，作⽤是截取某个字符串中的⼦串，⽤法有两种形式： string s2 = s.substr(4); // 表示从下标4开始⼀直到结束string s3 = s.substr(5, 3); // 表示从下标5开始，3个字符 string的size()或length()函数，可以直接获得string的长度 string的begin()以及end()方法可以用于sort排序 C++ STL之动态数组vector（⽮量）的使⽤ 基本使用方法 #include &lt;iostream&gt;#include &lt;vector&gt; int main() &#123; vector&lt;int&gt; v1; // 定义⼀个vector v1，定义的时候没有分配⼤⼩ cout &lt;&lt; v1.size(); // 输出vector v1的⼤⼩，此处应该为0 return 0; &#125; vector 可以⼀开始不定义⼤⼩，之后⽤ resize ⽅法分配⼤⼩，也可以⼀开始就定义⼤⼩，之后还可以对它插⼊删除动态改变它的⼤⼩；它都能够直接将所有的值初始化为0（不⽤显式地写出来，默认就是所有的元素为0) vector&lt;int&gt; v(10); // 直接定义⻓度为10的int数组，默认这10个元素值都为0// 或者vector&lt;int&gt; v1;v1.resize(8); //先定义⼀个vector变量v1，然后将⻓度resize为8，默认这8个元素都是0// 在定义的时候就可以对vector变量进⾏初始化vector&lt;int&gt; v3(100, 9);// 把100⻓度的数组中所有的值都初始化为9// 访问的时候像数组⼀样直接⽤[]下标访问即可～(也可以⽤迭代器访问，下⾯会讲～)v[1] = 2;cout &lt;&lt; v[0]; vectcor常用方法示例 #include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123; vector&lt;int&gt; a; // 定义的时候不指定vector的⼤⼩ cout &lt;&lt; a.size() &lt;&lt; endl; // 这个时候size是0 for (int i = 0; i &lt; 10; i++) &#123; a.push_back(i); // 在vector a的末尾添加⼀个元素i &#125; cout &lt;&lt; a.size() &lt;&lt; endl; // 此时会发现a的size变成了10 vector&lt;int&gt; b(15); // 定义的时候指定vector的⼤⼩，默认b⾥⾯元素都是0 cout &lt;&lt; b.size() &lt;&lt; endl; for (int i = 0; i &lt; b.size(); i++) &#123; b[i] = 15; &#125; for (int i = 0; i &lt; b.size(); i++) &#123; cout &lt;&lt; b[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; vector&lt;int&gt; c(20, 2); // 定义的时候指定vector的⼤⼩并把所有的元素赋⼀个指定的值 for (int i = 0; i &lt; c.size(); i++) &#123; cout &lt;&lt; c[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; for (auto it = c.begin(); it != c.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;;// 使⽤迭代器的⽅式访问vector &#125; return 0; &#125; 容器 vector 、 set 、 map 这些遍历的时候都是使⽤迭代器访问的。c.begin() 是⼀个指针，指向容器的第⼀个元素， c.end() 指向容器的最后⼀个元素的后⼀个位置，所以迭代器指针 it 的for循环判断条件是 it != c.end() 2019.8.18更新C++ STL之集合set的使⽤ set是集合，一个set里面的各个元素是各不相同的，而且set会按照元素从大到小排序(既能保证元素不重复，又能从大到小排序) set的常用用法#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;int main()&#123; set&lt;int&gt; s ; //定义一个空set集合s s.insert(1); //向集合s里插入一个1 cout&lt;&lt;*(s.begin()) &lt;&lt; endl; //输出集合的第一个元素 for(int i = 0 ; i &lt; 6 ; i) &#123; s.insert(i); //向集合s插入i &#125; for(auto it = s.begin() ; it != s.end() ; it++) &#123; //用迭代器遍历集合中的每一个元素 cout&lt;&lt;*it&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl&lt;&lt;(s.find(2) != s.end()) &lt;&lt;endl; //查找集合s中的值，如果结果等于s.end()表示为未找到(因为s.end()表示s的最后一个元素的下一个所在位置) cout&lt;&lt;(s.find(10) != s.end()) &lt;&lt; endl ;//s.find(10) != s.end()表示能找到10这个元素 s.erase(1); //删除集合s中的1这个元素 cout&lt;&lt;(s.find(1) != s.end()) &lt;&lt; end; //这时1将无法找到 return 0 ; &#125; 未完待续]]></content>
      <categories>
        <category>C转C++教程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大学半里程总结]]></title>
    <url>%2F2019%2F08%2F11%2F%E5%A4%A7%E5%AD%A6%E5%8D%8A%E9%87%8C%E7%A8%8B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[那个晚上时光一转，我又回到两年前。2017年六月高考出分的那个晚上，注定是终身难忘的一刻。失意雅不惬，见花如见仇。 一切都定格在513，高考的失误，让我与原本打算要上的全国重点学校失之交臂。也许，天意难违，我考出历次模拟最差分数。 这一天注定是河北地质大学，我唯能上的几所省内本一学校。还依稀记得是学院组织几个大三学长学姐给我们介绍了信工试点班(计算机科学与技术专业)。从小到大，我都是一个很要强的人。从初中年年的年级第一，到高中三年学习成绩的迅速走下，再到高考分数的雪崩式崩溃。我的内心早就已经五味杂陈。为了能在大学”翻身”—我毅然决然地选择进试点班。 第一年进入大学后，我活得从来没有的自由。从小长大养成的学习习惯迅速被丢弃，大一上学期，在半玩半学的悠闲日子中度过。绩点:2.9到了第二学期，我便重新打起精神，自觉上自习。提前学习C语言知识，在期末考出了3.5的高绩点。 那时思考大一结束了，我感觉自己所学的不过一些最基本的知识，考试不过是老师有意降低了出题难度。我感到一种空虚。 第二年大二，校本部。我亲眼目睹了很多同学已经变了，降低了对自己的要求。“我不能，我还要翻身！”大二上学期学的很是不好，来到本部后，老师知道试点班作业很多，于是就基本上不给我们留作业。这直接导致我自制力大幅度降低，特别是体现在数据结构考试上，我的分数很差。绩点3.2下学期，我开始每天晚上自觉去上自习，自觉做课本后面的习题。还好除了基本科目没能实现目标分数外，总体上过得去。 此时思考大二已结束，大三意味着2021毕业已近在咫尺，what should I do ?试点班已不再像以前在考研面试占优势(因为我们这届的能力已经大不如往届)坐以待毙？这要从大二下学期那个三月说起:师范大学举办了“云淮杯”竞赛，我发现我连师大大一的学生编程能力都不如。数据结构白学了?连一个图的基本遍历都写不出来???四月底学校组织的河北省程序设计大赛选拔，我又失败了。“我不是一个能靠幸运为助力，获得成功的人，永远都不可能是。” 2019年度计划面对自己的处境，我早已为自己在2019年对自己提出要求，“五个新”。 新方法重构学习方法，两个重点：课上与课下。课上: 逐步将听课效率提高到最佳课下：在保证自制力的情况下，全面提高学习效率。 新途径确定通过程序竞赛带动计算机学科各方面发展，快速、高效地提高编程综合能力。，为今后考研工作提供一个亮点。 新标准坚持努力考研，做提前准备，目标最低为省外211大学英语要600分通过六级程序竞赛的PAT甲级要在80分以上，蓝桥杯要在二等或二等奖以上在日常学习中，全面实现自控，养好良好的生活学习习惯。在成绩上，要排到专业前3名以内 新锻炼2019.6成功当选英语社团主席，通过这一机会，全面提高与他人交流能力以及处理日常事务的能力。 新时代实现学期全部学科绩点4.0，灵活、熟练掌握各科学习知识，将时间化整为零，实现各科高效学习 在行动 与7月正式启动PAT竞赛训练 与8月初启动英语考研语法与单词背诵 为未来，不辱使命谢谢访问]]></content>
      <categories>
        <category>生活记录</category>
      </categories>
      <tags>
        <tag>生活记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++第四周plus]]></title>
    <url>%2F2019%2F08%2F10%2FC-%E7%AC%AC%E5%9B%9B%E5%91%A8plus%2F</url>
    <content type="text"><![CDATA[C++面对对象程序设计第二节静态成员和静态成员函数 定义与java相同，这里只讨论其独特性质 静态成员函数访问的四种方式 类名+成员名 A :: Print(); 对象名.成员名 A m;m.Print(); 指针-&gt;成员名 A *p;p-&gt;Print(); 引用 A &amp;p;p.Print(); 静态成员变量本质是全局变量 静态成员变量必须在定义的文件中对其进行初始化或赋值，否则编译通过，链接不通过。 class A&#123; static int m ;&#125;;int A :: m = 0 ; //赋值 静态成员函数内可以以访问非静态成员函数以及非静态变量 成员对象与友元类 成员对象:第一个类的成员变量是另一个类的对象 包含对象的类叫做封闭类 封闭类的构造函数形式类名+构造函数(参数表):成员变量(参数表),成员变量2(参数表)… //成员对象与封闭类class examples&#123; public: example a ; int b ; int c ; int e ; examples(int m ,int n) : a(m-n,m+n,m*n),e(m)&#123;&#125;; &#125;;//使用examples p (1,2); 对于封闭类构造与析构顺序成员对象:先构造后析构封闭对象:后构造先析构 友元类 友元函数 友元函数可以访问类的私有成员 将一个类的成员函数定义为另一个友元 友元类A是B的友元类，A的成员函数可以访问B的私有成员 class B&#123; private: int a ; friend class A ;&#125;;class A&#123; B m ; void Print() &#123; cout &lt;&lt; m.a &lt;&lt; endl ; &#125;&#125;; 友元类不能传递，不能继承 this 指针 非静态成员函数中可以直接使用this指针，代表指针该函数体用的对象指针 class A&#123; int i ; public: void Hello &#123;cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl;&#125; //等价于 void Hello (A*this) &#123;cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl;&#125;&#125;;int main()&#123; A* p = NULL; p-&gt;Hello(); //输出Hello&#125; this函数不能作用静态变量以及全局变量。可以作用与const变量 常量成员函数 定义方法 class A&#123; void Print(const a) const &#123; cout &lt;&lt; endl ;&#125;&#125;; 常量成员不能调用非常量成员函数 常量成员函数不能调用非常量成员变量 谢谢访问]]></content>
      <categories>
        <category>旗舰学科</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>旗舰学科</tag>
        <tag>计算机语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++第四周]]></title>
    <url>%2F2019%2F08%2F10%2FC%2B%2B%E7%AC%AC%E5%9B%9B%E5%91%A8%2F</url>
    <content type="text"><![CDATA[C++面对对象程序设计第一节类的相关知识 与java不同，类的最后}需要加分号 成员函数外部描述方式 int CRectangle :: Area()&#123; return weight*high;&#125; 注意：如果在类外写成员函数，需要在类定义中声明class A&#123; int a ,b; void Print();&#125;;void A ::Print()&#123; cout &lt;&lt; endl;&#125; 类的可访问范围与java不同的是，如果不写范围，默认为private 设置私有成员机制 —隐藏 设置私有成员目的 —强制对成员进行隐藏类的相关函数内联成员函数定义的两种方式: line + 成员函数 整个函数出现在类定义外部重载成员函数 定义: 成员函数可带缺省值 注意！！！:使用缺省函数注意避免函数重载的歧义class A&#123; void value(int val = 0 ) &#123;x = val ;&#125; void value() &#123;cout &lt;&lt; endl ;&#125; //歧义&#125;; A m ; m.value(); //编译器不知道要调用哪个成员函数 复制(拷贝)构造函数 若没有复制构造函数，则默认生成 complex c1 ; //拷贝(初始化语句，并非赋值语句)complex c2 = c1 ;complex c3(c2);//赋值语句c3 = c2 复制构造函数的参数必须是对象的引用，且参数只有一个、没有返回值 complex (complex &amp; a) //正确complex (complex a) //错误 复制构造函数使用的三种情况 初始化新的对象 函数调用时输入形参，形参到实参其实是自已利用复制构造函数自己有生成了并初始化了一个新的对象 函数返回一个对象，其实是自已利用复制构造函数自己有生成了并初始化了一个新的对象，并将其返回 注意问题如果复制构造函数是自己写的，那么可能就与上面三种情况结果不同(不一定返回对象，对象性质不一定相同等等)强制类型转换函数 目的：实现类的自动转换 特点 只有一个参数 并非复制构造函数 实例class A&#123; public: double real ,imag; complex(int i)u; &#123; cout &lt;&lt; &quot;intconstructor called&quot;&lt;&lt;endl; real = 2 ; imag = 0; &#125; complex (double r , double i) &#123;real = r ; imag = &#125;&#125;;int main()&#123; complex c1(7,8); complex c2 = c1; c1 = 9 ; //12以及9被自动转换成一个临时的complex对象&#125; 2019.8.10更新 析构函数 成员函数中的一种，名字与类名相同，没有参数也没有返回值，一个类最多只有一个析构函数 对象消亡时，自动被调用 在析构函数加入delete运算符，可以释放new申请的空间 对象数组的每个元素的析构函数都会被调用 注意: 语句块结束后，自动调用析构函数 函数结束，自动调用析构函数 谢谢访问]]></content>
      <categories>
        <category>旗舰学科</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>旗舰学科</tag>
        <tag>计算机语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[摘录]]></title>
    <url>%2F2019%2F08%2F09%2F%E6%91%98%E5%BD%95%2F</url>
    <content type="text"><![CDATA[愿你三冬暖，愿你春不寒。愿你天黑有灯，下雨有伞。愿你路上有良人相伴，愿你此生尽兴、赤诚善良。 愿时光能缓，愿故人不散。愿有人陪你颠沛流离，愿你惦念的人能和你道早安，愿你独闯的日子里不觉得孤单。愿你人间走一遭，圆满了三界六道，看透了是非善恶。从此福来心至，皆是逍遥。]]></content>
      <categories>
        <category>生活记录</category>
      </categories>
      <tags>
        <tag>生活记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++第三周]]></title>
    <url>%2F2019%2F08%2F09%2FC-%E7%AC%AC%E4%B8%89%E5%91%A8%2F</url>
    <content type="text"><![CDATA[第一节 const常量使用 定义常量 const int m = 3 ; 定义常量指针 const int* m ; 不可以通过常量指针修改其指向的内容，但可以改动其指向内容的值 定义常引用 const int&amp; m; 不能通过常引用修改其指向的变量 第二节 动态内存的分配 用法一:分配一个空间 int *p = new int; 用法二:分配一个数组 int* p = new int[N]; 分配一片大小为N*sizeof(int)的空间，并将其起始地址返回N可以为变量,new的返回值为地址 用delete运算符释放new运算符申请的内存//申请 int*p = new int ;int*s = new int[n];//释放delete p;delete[] s; 第三节 C++函数 内联函数当函数语句较短多次调用时，采用内联函数，可以降低有函数调用带来的消耗 inline int func()&#123; int m = 0 ; return 0 ;&#125; 函数重载函数名字相同，参数必须不同。 //eg1int max(int a ,int b);int max(int a ,int b ,int c);//eg2(常量成员函数)int value(int a ,int b) const &#123;return 0 ;&#125;int value(int a ,int b) &#123;return 0 ;&#125; 函数缺省参数在C++中，定义函数的时候可以让最右边的连续若干个参数有缺省值。则调用函数的时候，若相应位置不写参数，参数值就是缺省值。 void fun(int a ,int b ,int x3 = 3 )&#123;&#125;fun(10); //等效于fun(10,2,3)fun(10,12); //等效于(10,12,6) 作用:提高了函数的可扩展性。 谢谢访问]]></content>
      <categories>
        <category>旗舰学科</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>旗舰学科</tag>
        <tag>计算机语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构第一周]]></title>
    <url>%2F2019%2F07%2F20%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E5%91%A8%2F</url>
    <content type="text"><![CDATA[线性表 定义:线性表简称表，包含零个或多个元素的有序序列 属性 表目 == 记录 索引 == 下标 二元组B = (K,R) , K = {a0,a1,a2,…an-1} R = {r} 具有反对称性 , a1是a2的(直接)前驱，a2是a1的(直接)后继 特点 均匀性: 元素类型相同 有序性 线性结构分类 简单:线性表、栈、队列、散列表 难：广义表，多维数组、文件 访问方式 直接访问 间接访问 目录访问 (线性)表的三个方面 逻辑结构 存储结构 运算 线性表的逻辑结构 属性：长度、表头、表尾、位置 有存储结构可分为 顺序表(是由数组实现的) 链表 按操作可分为 栈 队列 按运算清除操作、插入操作、删除操作等 顺序表 亦称向量，由数组实现 特性 元素相同 顺序、连续储存 元素地址公式 Loc(i) = Loc(i0) + c * i 其中 (c = sizeof(ELEM)); 顺序表插入与删除的算法分析 插入移动次数: n - i 删除移动次数：n - i - 1 未完待续 谢谢访问]]></content>
      <categories>
        <category>旗舰学科</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>旗舰学科</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++第二周]]></title>
    <url>%2F2019%2F07%2F17%2FC-%E7%AC%AC%E4%BA%8C%E5%91%A8%2F</url>
    <content type="text"><![CDATA[第一节 相关函数补充C++ STL中的Binary search（二分查找）头文件#include &lt;algorithm&gt; binary_search(参数一、参数二、参三) 函数模板binary_search(arr[],arr[]+size , indx) 参数说明(1)arr[]:数组首地址(2)size:数组元素个数(3)indx:需要查找的值 函数功能 在数组以二分法检索的方式查找，若在数组(要求数组元素非递减)中找到indx元素则返回true，否则false lower_bound(参数一、参数二、参三) 函数模板 lower_bound(arr[],arr[]+size , indx) 参数说明(1)arr[]:数组首地址(2)size:数组元素个数(3)indx:需要查找的值 函数功能 函数lower_bound()在first和last中的前闭后开区间进行二分查找，返回大于或等于val的第一个元素位置(注意是地址)。如果所有元素都小于val，则返回last的位置 upper_bound(参数一、参数二、参三) 函数模板 upper_bound(arr[],arr[]+size , indx) 参数说明(1)arr[]:数组首地址(2)size:数组元素个数(3)indx:需要查找的值 函数功能 函数upper_bound()返回的在前闭后开区间查找的关键字的上界，返回大于val的第一个元素位置 谢谢访问]]></content>
      <categories>
        <category>旗舰学科</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>旗舰学科</tag>
        <tag>计算机语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷p1015]]></title>
    <url>%2F2019%2F07%2F17%2F%E6%B4%9B%E8%B0%B7p1015%2F</url>
    <content type="text"><![CDATA[洛谷p1015题目描述若一个数（首位不为零）从左向右读与从右向左读都一样，我们就将其称之为回文数。例如：给定一个十进制数56，将56加65（即把5656从右向左读），得到121是一个回文数.又如：对于十进制数87：STEP1：87+78 = 16STEP2：165+561 = 726STEP3：726+627 = 1353STEP4：1353+3531 = 4884在这里的一步是指进行了一次N进制的加法，上例最少用了4步得到回文数4884.写一个程序，给定一个N(2 &lt;= N &lt;= 10,N =16 )进制数M(100位之内)，求最少经过几步可以得到回文数。如果在30步以内（包含30步）不可能得到回文数，则输出Impossible! 输入输出格式输入格式两行，分别是N,M. 输出格式STEP=ans 题目分析 首先此类题目设计数字的反转，不妨想到用字符串进行操作更方便。同时，C++的reverse()函数，方便了字符串的反转 其次，我们应学会高效率的进制转换 通过计数器进行STEP计数，我们便可求解代码示例#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;using namespace std;unsigned long long n=0,k,len,nex;string nn;bool wow(unsigned long long a)&#123; unsigned long long s=0; for (unsigned long long i=a;i;i/=k) //第三个for循环 s=s*k+i%k; nex=s+a; return s==a;&#125;unsigned long long ch(char a)&#123; if (a&gt;=&apos;0&apos; &amp;&amp; a&lt;=&apos;9&apos;) return a-&apos;0&apos;; return a-&apos;A&apos;+10;&#125;int main()&#123; cin&gt;&gt;k&gt;&gt;nn;len=nn.size(); for (int i=0;i&lt;len;i++) //第一个for循环 n=n*k+ch(nn[i]); unsigned long long step; for (step=0;!wow(n) &amp;&amp; step&lt;=30;step++) //第二个for循环 n=nex; if (step&lt;=30) cout&lt;&lt;&quot;STEP=&quot;&lt;&lt;step&lt;&lt;endl; else cout&lt;&lt;&quot;Impossible!&quot;; return 0;&#125; 代码分析 首先，数字以字符串输入，通过第一个for循环，可直接将任意进制转换为十进制(大大降低了用栈求进制的麻烦).这里涉及到一个数学知识，即秦久韶公式，大家可以搜索了解下 第三个for循环更加精巧.通过一个for循环，将一个十进制数变成相应的反转后k进制数，再转换为十进制数。 wow函数内部通过比较反转前后的k进制数的十进制进行比较，如果相等，则返回true，若不相等，则再次调用wow函数，直到为true或STEP &gt; 30 数字字符串转化为数字.ch函数巧妙地运用ASDII码的特性，将单个字符转化为单个数字 追加学习字符串反转 使用string.h中的strrev函数。 char s[20] = &quot;hello&quot;;strrev(s);cout&lt;&lt;s&lt;&lt;endl; //输出为 olleh 使用algorithm中的reverse函数 string s[20] = &quot;hello&quot;;reverse(s.begin(),s.end()); //也可写成reverse(s)cout&lt;&lt;s&lt;&lt;endl; //输出为 olleh 字符数字转数字利用ASDII码特性，字符数字 - ‘0’ 即为对应数字，字母 - ‘A’ + 10 即为9以上对应数字 unsigned long long ch(char a)&#123; if (a&gt;=&apos;0&apos; &amp;&amp; a&lt;=&apos;9&apos;) return a-&apos;0&apos;; return a-&apos;A&apos;+10;&#125; 进制转换 利用C++栈转换 #include &lt;iostream&gt; #include &lt;stack&gt; using namespace std; int main() &#123;int b,n,e;cout &lt;&lt; &quot;请输入数制转换的进制及数值：&quot;&lt;&lt;endl;cin &gt;&gt; b &gt;&gt; n;cout &lt;&lt; &quot;数值&quot; &lt;&lt; n &lt;&lt; &quot;的&quot; &lt;&lt; b &lt;&lt; &quot;进制为：&quot; &lt;&lt; endl;stack&lt;int&gt;stk; //重点while (n)&#123; stk.push(n%b); n /= b;&#125;while (!stk.empty())&#123; cout &lt;&lt; stk.top(); stk.pop();&#125;return 0; &#125; 利用秦九韶公式转换(仅仅适用于K进制转十进制) for (int i=0;i&lt;len;i++) //第一个for循环 n=n*k+ch(nn[i]); C++栈的使用说明 使用栈，要先包含头文件： #include &lt;stack&gt; 定义栈，以如下形式实现： stack&lt;Type&gt; s; //其中Type为数据类型（如 int，float,char等）。 栈的主要操作 s.push(S); //将S压入栈顶 s.pop(); //删除栈顶的元素，但不会返回 s.top(); //返回栈顶的元素，但不会删除 s.size(); //返回栈中元素的个数 s.empty(); //检查栈是否为空，如果为空返回true，否则返回false 谢谢访问]]></content>
      <categories>
        <category>蓝桥杯周练</category>
        <category>蓝桥杯周练之序周</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>竞赛</tag>
        <tag>数据结构</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1012]]></title>
    <url>%2F2019%2F07%2F16%2F%E6%B4%9B%E8%B0%B7P1012%2F</url>
    <content type="text"><![CDATA[洛谷P1012题目描述设有n个正整数(n≤20)，将它们联接成一排，组成一个最大的多位整数。例如：n=3时，3个整数13,312,343联接成的最大整数为：34331213又如：n=4时，4个整77,13,4,246联接成的最大整数为：7424613 输入输出格式输入格式 ：第一行，一个正整数n。第二行，n个正整数。 输出格式：一个正整数，表示最大的整数 输入输出样例输入313 312 343 输出34331213 题解本题涉及到数字的拼接，显然是考字符串的使用代码如下#include&lt;bits/stdc++.h&gt; //万能头文件using namespace std;string a[21]; //比较函数 bool cmp(string a , string b) &#123; return a + b &gt; b +a ; // a + b 就是a接在b的后面 &#125;int main()&#123; int n = 0 ; cin &gt;&gt; n ; for(int i = 1 ; i &lt;= n ; i++) cin &gt;&gt; a[i]; //C++的sort函数 sort(a+1,a+n+1,cmp); for(int i = 1 ; i &lt;= n ; i++) cout &lt;&lt; a[i]; return 0;&#125; 代码解析之万能头文件#include&lt;bits/stdc++.h&gt; 代码解析之C++Sort函数sort函数有三个参数(第三个参数定义排序规则，可有可无). 第一个参数为排序的起始位置 第二个参数为排序的终止位置 第三个参数默认不写为升序排序，若自定义，则需要构造排序规则函数，且第三个参数直接收bool类型 代码解析之C++string类 string是指字符串数组，相当于char[num]; String有如下赋值方法 string str1 = &quot;first&quot;; //拷贝初始化 string str2(&quot;hello&quot;); //直接初始化 直接初始化:使用普通的函数匹配即可完成初始化。也就是说只是直接调用类的构造函数或拷贝构造函数就能完成初始化的就是直接初始化; 拷贝初始化:将对象拷贝到正在创建的对象当中，如果需要还要进行类型转换。这里也就是间接调用拷贝构造函数，当然大部分情况调用拷贝构造函数，有时也可能调用移动构造函数。 常用函数 string m ; string s ;m.begin(); //字符数组的起始地址m.end(); //字符数组的终止地址m.append(s) //字符串拼接 string 拼接的几种方法 1、str += “a”， str =str+ “a” 效率差距str =str+ “a”加的运算产生的是一个新的对象，再把结果返回;而str += “a” 涉及到的应该是对象的引用，操作之后直接返回引用，避免了产生新的对象。 使用append(); void main(void) &#123; string s1(&quot;hello&quot;); string s2(&quot;word&quot;); s1.append(s2); cout &lt;&lt; s1 ; &#125;//输出结果hello word 直接拼接 string s1 ;string s2 ;s2 = s2 + s1 ; //s1拼接在s2后面 字符串比较规则比较的时候，从字符串左边开始，一次比较每个字符，直接出现差异、或者其中一个串结束为止.比如ABC与ACDE比较，第一个字符相同，继续比较第二个字符，由于第二个字符是后面一个串大，所以不再继续比较，结果就是后面个串大.应用以上原理，用字符串解决洛谷p1012再方便不过了 谢谢访问]]></content>
      <categories>
        <category>蓝桥杯周练</category>
        <category>蓝桥杯周练之序周</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>竞赛</tag>
        <tag>数据结构</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法第一周]]></title>
    <url>%2F2019%2F07%2F14%2F%E7%AE%97%E6%B3%95%E7%AC%AC%E4%B8%80%E5%91%A8%2F</url>
    <content type="text"><![CDATA[枚举法看似很low，其实很强大！！！ 枚举相关概念及性质 应用范围:基于已有知识进行答案猜测的思想 枚举思想: 猜测 使用枚举需确定三个问题 问题一 :确定解空间，建立简洁的数学模型(可能出现的情况的集合) 问题二 :利用所学知识以及题目中的条件减少变量取值范围 问题三 :依据题目确定正确的搜索顺序(搜索空间的遍历顺序要与模型中条件表达式一致) 枚举法举例问题:求小于N的最大素数 问题一解空间为:(1)正整数(2)值大于2(3)n不能被[2,n)中任意一个素数整除(注意不是n不能被[2,n)中任意一个整数整除) 问题二优化解空间:除2以外的所有偶数，一定不是素数。即{2,2 i+1 |1&lt;=i, 2 i+1 &lt; n } 问题三对{2,2 i+1 |1&lt;=i, 2 i+1 &lt; n} 按照从小到大的顺序 请尝试如下题目百鸡问题鸡翁一值钱五, 鸡母一值钱三, 鸡雏三值钱一百钱买百鸡, 问鸡翁, 鸡母, 鸡雏各几何 2019-7-17更新 题解: 先构造可能的解的集合 S={(X,Y,Z)|0&lt;=X,Y,Z&lt;=100}X, Y, Z分别代表买公鸡, 母鸡和小鸡的只数 然后验证条件X+Y+Z=100, 5X+3Y+Z/3=100 复杂度: O(100^2) 伪代码 for (int x=0; x&lt;=100; x++) for (int y=0 ; y&lt;=100-x; y++)&#123; z = 100 - x - y; if (z % 3==0) then if (5*x+3*y+z/3==100) then (x,y,z) is solution&#125; 谢谢访问]]></content>
      <categories>
        <category>旗舰学科</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>旗舰学科</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++第一周]]></title>
    <url>%2F2019%2F07%2F13%2FC-%E7%AC%AC%E4%B8%80%E5%91%A8%2F</url>
    <content type="text"><![CDATA[第一节 函数指针与命令行参数函数指针1.格式类型名 + (*指针变量名) + (参数一类型、参数二类型….);示例#include &lt;stdio.h&gt; void PrintMin(int a,int b) &#123; if( a&lt;b ) &#123; printf(&quot;%d&quot;,a); &#125; else &#123; printf(&quot;%d&quot;,b); &#125; &#125; int main() &#123; void (* pf)(int ,int); int x = 4, y = 5; pf = PrintMin; pf(x,y); return 0; &#125; 2.C++的qsort()函数使用qsort(起始地址,长度,每个元素字节大小,排序规则)；示例如下:#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int MyCompare( const void * elem1, const void * elem2 )&#123; unsigned int * p1, * p2; p1 = (unsigned int *) elem1; // “* elem1” 非法 p2 = (unsigned int *) elem2; // “* elem2” 非法 return (* p1 % 10) - (* p2 % 10 );&#125;#define NUM 5int main()&#123; unsigned int an[NUM] = &#123; 8,123,11,10,4 &#125;; qsort( an,NUM,sizeof(unsigned int), MyCompare); for( int i = 0;i &lt; NUM; i ++ ) printf(&quot;%d &quot;,an[i]); return 0;&#125; 命令行参数1.格式:int main(int argc , char* argv[]) 其中，argc为参数个数，argv为char**类型2.命令行参数以空格或回车为一个参数的结束，若参数包含回车，请用” “包裹起来 第二节 位运算&amp;（与）运算eg: 21 &amp; 18 = 16即这个数的二进制数对应位均为1时，则该位为1，其余任何时刻均为0应用: 某些位清零，其他位不变 获取变量中的某一位 |(或)运算eg: 21 | 18 = 23 将某些位置置为1，其他不变 ^(异或)eg: 21 ^ 18 = 23规律:若 a ^ b = c则有：c ^ a = b ;c ^ b = a ; ~(取反)运算&lt;&lt;(左运算)eg: 9 &lt;&lt; 4 = 1449的二进制编码: 0000 1001左移四位:1001 0000 左移一位乘2，左移n位乘2的n次方 &gt;&gt;(右移)运算 对于有符号的数，前面补充的数为符号对应的数 对于无符号的数，前面补0 右移一位除2，右移n位除以2的n次方 如果除不尽，则向较小的整数靠近 第三节 引用 类型名 &amp; 引用名 = 某变量名 注意一下几个规则 定义引用时必须初始化成某一 变量 一旦初始化，不能再引用其他变量，”=”仅仅时赋值 只能引用变量 变量可以做函数返回值 const &amp; r 为常引用，不能通过该引用改变被引用的变量值变量做函数返回值示例 int n = 4;int &amp; SetValue()&#123; return n; &#125;int main()&#123; SetValue() = 40; cout &lt;&lt; n; return 0;&#125; //输出： 40 谢谢访问]]></content>
      <categories>
        <category>旗舰学科</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>旗舰学科</tag>
        <tag>计算机语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构前言]]></title>
    <url>%2F2019%2F07%2F13%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%89%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[数据结构认识数据结构组成数据结构 = 逻辑结构 + 储存结构 + 运算 逻辑结构组成(1)线性结构: 表(List)、栈(Stack)、队列(queue)、串(String)(2)非线性结构: 树、图(3)逻辑结构包含关系 线性表 $\subseteq$ 二叉树 $\subseteq$ 树 $\subseteq$ 图 储存结构(1)逻辑结构到物理存储的映射(2)常见储存结构：顺序结构链表索引散列 抽象数据类型先定义逻辑结构(数据对象及其关系)，再定义算法(数据操作) 数据结构学习需用到的C++知识补充类(1)类中的变量: 构成数据结构(2)类中的函数: 封装数据结构(3)如果成员变量没给出适用范围，默认为private 类函数的外部声明方法函数返回值类型 + 类名 + :: + 函数名(参数1，参数2….) C++函数模板template &lt;typrname T&gt;void print (const T &amp; left , const T &amp; right )&#123; //语句&#125;//使用print&lt;int&gt;(25,30); 谢谢访问]]></content>
      <categories>
        <category>旗舰学科</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>旗舰学科</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
