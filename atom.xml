<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>星辰</title>
  
  <subtitle>McKinley Lu</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mckinleylu.com/"/>
  <updated>2020-04-13T09:10:43.564Z</updated>
  <id>http://mckinleylu.com/</id>
  
  <author>
    <name>McKinley Lu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OS内list.h函数部分讲解</title>
    <link href="http://mckinleylu.com/2020/04/13/list-h/"/>
    <id>http://mckinleylu.com/2020/04/13/list-h/</id>
    <published>2020-04-13T07:05:43.000Z</published>
    <updated>2020-04-13T09:10:43.564Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="List-h部分函数"><a href="#List-h部分函数" class="headerlink" title="List.h部分函数"></a>List.h部分函数</h3><h4 id="初始化操作"><a href="#初始化操作" class="headerlink" title="初始化操作"></a>初始化操作</h4><ul><li><p>首先，向函数内部传入链表头节点</p></li><li><p>在函数中，使头节点的pre以及next指针指向头节点 ，即 next = pre = head <a id="more"></a></p></li><li><p>参考代码</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_init</span><span class="params">(ListHead *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line"><span class="built_in">list</span>-&gt;prev = <span class="built_in">list</span>-&gt;next = <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>效果图</p><p><img src="/images/init.png" style=" margin:0 auto;  "></p></li></ul><h3 id="判断空操作"><a href="#判断空操作" class="headerlink" title="判断空操作"></a>判断空操作</h3><ul><li><p>首先，向函数内部传入链表头节点</p></li><li><p>在函数中，判断头节点是否与它的其中一个指针分量值相同，若相同，则返回true，否则返回false</p></li><li><p>参考代码</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> boolean <span class="title">list_empty</span><span class="params">(ListHead *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">list</span> == <span class="built_in">list</span>-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="向头节点后部添加节点操作"><a href="#向头节点后部添加节点操作" class="headerlink" title="向头节点后部添加节点操作"></a>向头节点后部添加节点操作</h3><ul><li><p>首先，向函数内部传入链表头节点以及要插入节点的listhead分量指针</p></li><li><p>在函数中调用List_add()函数</p><ul><li>第一个参数为链表头节点指针</li><li>第二参数为链表头节点下一个节点的指针</li><li>第三个参数为待插入节点的listhead分量指针</li></ul></li><li><p>接下来分析List_add()函数</p><ul><li><p>首先判断待插入节点的listhead分量指针是否为空，如果为空，则退出程序，否则，执行以下步骤</p></li><li><p>在这里  参数 pre = head  next  =  head-&gt;next  data为待插入节点的listhead分量指针</p><p>（第一次插入 其实质为 next = pre = head ， 第i次插入其实质为 pre = head next = 上一个插入节点的listhead分量指针）</p></li><li><p>首先，待插入节点的listhead分量指针的pre分量设置成pre参数值</p></li><li><p>待插入节点的listhead分量指针的next分量设置成next参数值</p></li><li><p>最后，设置参数pre的next等于data，数next的pre等于data</p></li></ul></li><li><p>参考代码</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_add_after</span><span class="params">(ListHead *<span class="built_in">list</span>, ListHead *data)</span> </span>&#123;</span><br><span class="line">list_add(<span class="built_in">list</span>, <span class="built_in">list</span>-&gt;next, data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_add</span><span class="params">(ListHead *prev, ListHead *next, ListHead *data)</span> </span>&#123;</span><br><span class="line">assert(data != <span class="literal">NULL</span>);                               <span class="comment">//报错&amp;&amp;终止程序！</span></span><br><span class="line">data-&gt;prev = prev;</span><br><span class="line">data-&gt;next = next;</span><br><span class="line"><span class="keyword">if</span> (prev != <span class="literal">NULL</span>) prev-&gt;next = data;</span><br><span class="line"><span class="keyword">if</span> (next != <span class="literal">NULL</span>) next-&gt;prev = data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>只插一个节点的效果图</p><p><img src="/images/list_add.png" style=" margin:0 auto;  "></p></li><li><p>插两个节点的过程图</p><p><img src="/images/list_add_after.png" style=" margin:0 auto;  "></p></li><li><p>插两个节点的效果图</p><p><img src="/images/list_add_after_re.png" style=" margin:0 auto;  "></p></li></ul><h3 id="向头节点前部添加节点操作"><a href="#向头节点前部添加节点操作" class="headerlink" title="向头节点前部添加节点操作"></a>向头节点前部添加节点操作</h3><ul><li><p>在这里，我们只需比较传入List_add()函数参数就可以了</p></li><li><p>在list_after函数中，   pre =  头节点地址   next  =  头节点的后继节点地址   data为待插入节点的listhead分量指针</p><p>而在list_before函数中，pre = 头节点的前驱节点地址   next = 头节点地址    data为待插入节点的listhead分量指针</p></li><li><p>参考代码</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="title">voidlist_add_before</span><span class="params">(ListHead *<span class="built_in">list</span>, ListHead *data)</span> </span>&#123;</span><br><span class="line">list_add(<span class="built_in">list</span>-&gt;prev, <span class="built_in">list</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_add</span><span class="params">(ListHead *prev, ListHead *next, ListHead *data)</span> </span>&#123;</span><br><span class="line">assert(data != <span class="literal">NULL</span>);                                  <span class="comment">//报错&amp;&amp;终止程序！</span></span><br><span class="line">data-&gt;prev = prev;</span><br><span class="line">data-&gt;next = next;</span><br><span class="line"><span class="keyword">if</span> (prev != <span class="literal">NULL</span>) prev-&gt;next = data;</span><br><span class="line"><span class="keyword">if</span> (next != <span class="literal">NULL</span>) next-&gt;prev = data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>只插一个节点的效果图</p><p><img src="/images/list_add.png" style=" margin:0 auto;  "></p></li><li><p>插两个节点的过程图</p><p><img src="/images/list_add_before.png" style=" margin:0 auto;  "></p></li><li><p>插两个节点的效果图</p><p><img src="/images/list_add_before_re.png" style=" margin:0 auto;  "></p></li></ul><h3 id="删除链表中节点操作"><a href="#删除链表中节点操作" class="headerlink" title="删除链表中节点操作"></a>删除链表中节点操作</h3><ul><li><p>我们只需向list_del()函数中传入要删除节点的指针</p></li><li><p>首先，我们需要判断是否删除的指针为空，如果为空，则直接报错退出，否则，进行下一步</p></li><li><p>接下来，我们设置两个指针保护要删除节点的前驱节点(pre)地址以及后继节点(next)地址</p></li><li><p>最后我们先判断pre以及next是否为空，如果为空，无需任何操作，否则，将</p><p>前驱节点(pre)的后继节点指针next设置为后继节点next</p><p>后继节点(next)的前驱节点指针pre设置为前驱节点pre</p></li><li><p>参考代码</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_del</span><span class="params">(ListHead *data)</span> </span>&#123;</span><br><span class="line">assert(data != <span class="literal">NULL</span>);</span><br><span class="line">ListHead *prev = data-&gt;prev;</span><br><span class="line">ListHead *next = data-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (prev != <span class="literal">NULL</span>) prev-&gt;next = next;</span><br><span class="line"><span class="keyword">if</span> (next != <span class="literal">NULL</span>) next-&gt;prev = prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除节点过程图</p><p><img src="/images/list_del.png" style=" margin:0 auto;  "></p></li><li><p>删除节点效果图</p><p><img src="/images/list_del_re.png" style=" margin:0 auto;  "></p></li></ul><h3 id="获取结构体起始指针"><a href="#获取结构体起始指针" class="headerlink" title="获取结构体起始指针"></a>获取结构体起始指针</h3><ul><li><p>0x0地址强制转换为<code>type *</code>类型，然后取<code>type</code>中的成员<code>member</code>地址，因为起始地址为0，得到的<code>member</code>的地址就直接是该成员相对于<code>type</code>对象的偏移地址了。</p></li><li><p>所以该语句的功能是：得到<code>type</code>类型对象中<code>member</code>成员的地址偏移量。<br> 先将<code>ptr</code>强制转换为<code>char *</code>类型（因为<code>char *</code>类型进行加减的话，加减量为<code>sizeof(char)*offset</code>，<code>char</code>占一个字节空间，这样指针加减的步长就是1个字节，实现加一减一。）</p></li><li><p>整句话的意思就是：得到指向<code>type</code>的指针，已知成员的地址，然后减去这个成员相对于整个结构对象的地址偏移量，得到这个数据对象的地址。</p></li><li><p>参考代码</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_entry(ptr, type, member) \</span></span><br><span class="line">((type*)((<span class="keyword">char</span>*)(ptr) - (<span class="keyword">int</span>)(&amp;((type*)<span class="number">0</span>)-&gt;member)))</span><br></pre></td></tr></table></figure></li><li><p>解析图</p><p><img src="/images/list_entry.png" style=" margin:0 auto;  "></p></li></ul><h3 id="谢谢访问"><a href="#谢谢访问" class="headerlink" title="谢谢访问"></a>谢谢访问</h3><div style=" width:747px; height: 447px; margin:0 auto">   <img src="/images/thank.jpg" style=" margin:0 auto;  ">  </div>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;List-h部分函数&quot;&gt;&lt;a href=&quot;#List-h部分函数&quot; class=&quot;headerlink&quot; title=&quot;List.h部分函数&quot;&gt;&lt;/a&gt;List.h部分函数&lt;/h3&gt;&lt;h4 id=&quot;初始化操作&quot;&gt;&lt;a href=&quot;#初始化操作&quot; class=&quot;headerlink&quot; title=&quot;初始化操作&quot;&gt;&lt;/a&gt;初始化操作&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;首先，向函数内部传入链表头节点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在函数中，使头节点的pre以及next指针指向头节点 ，即 next = pre = head
    
    </summary>
    
    
      <category term="OS" scheme="http://McKinleyLu.com/categories/OS/"/>
    
    
      <category term="OS" scheme="http://McKinleyLu.com/tags/OS/"/>
    
      <category term="List.h" scheme="http://McKinleyLu.com/tags/List-h/"/>
    
  </entry>
  
  <entry>
    <title>ubunte 代码初步</title>
    <link href="http://mckinleylu.com/2020/02/21/ubunte-%E4%BB%A3%E7%A0%81%E5%88%9D%E6%AD%A5/"/>
    <id>http://mckinleylu.com/2020/02/21/ubunte-%E4%BB%A3%E7%A0%81%E5%88%9D%E6%AD%A5/</id>
    <published>2020-02-21T09:03:36.000Z</published>
    <updated>2020-02-22T02:03:45.260Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h3><p>针对Ubunte 18.04版本，安装一下环境<a id="more"></a></p><p>gcc安装代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br></pre></td></tr></table></figure><p>或者使用代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get  build-dep  gcc</span><br></pre></td></tr></table></figure><p>g++安装代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install g++</span><br></pre></td></tr></table></figure><h3 id="VI使用初步"><a href="#VI使用初步" class="headerlink" title="VI使用初步"></a>VI使用初步</h3><p>创建(或打开已有)文件，同时进入命令模式</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi sum.c</span><br></pre></td></tr></table></figure><p>进入输入模式、编辑文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">esc键 + : set nocp</span><br></pre></td></tr></table></figure><p>回到命令模式</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">esc键</span><br></pre></td></tr></table></figure><p>保存文件并退出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:wq</span><br></pre></td></tr></table></figure><h3 id="执行C文件"><a href="#执行C文件" class="headerlink" title="执行C文件"></a>执行C文件</h3><ol><li><p>方法一</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc sum.c</span><br><span class="line">./a.out</span><br></pre></td></tr></table></figure></li><li><p>方法二</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc sum.c -o sum</span><br><span class="line">.\sum</span><br></pre></td></tr></table></figure></li></ol><h3 id="C文件内容及运行代码"><a href="#C文件内容及运行代码" class="headerlink" title="C文件内容及运行代码"></a>C文件内容及运行代码</h3><ol><li><p>C文件内容</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span> , sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= <span class="number">100</span> ; ++i)&#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行结果</p><p><img src="/images/2020.2.20.jpg" style=" margin:0 auto;  "></p></li></ol><h3 id="谢谢访问"><a href="#谢谢访问" class="headerlink" title="谢谢访问"></a>谢谢访问</h3><div style=" width:747px; height: 447px; margin:0 auto">   <img src="/images/thank.jpg" style=" margin:0 auto;  ">  </div>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;安装环境&quot;&gt;&lt;a href=&quot;#安装环境&quot; class=&quot;headerlink&quot; title=&quot;安装环境&quot;&gt;&lt;/a&gt;安装环境&lt;/h3&gt;&lt;p&gt;针对Ubunte 18.04版本，安装一下环境
    
    </summary>
    
    
      <category term="UNIX程序设计" scheme="http://McKinleyLu.com/categories/UNIX%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="vi&amp;&amp;vim" scheme="http://McKinleyLu.com/tags/vi-vim/"/>
    
  </entry>
  
  <entry>
    <title>Navicat安装</title>
    <link href="http://mckinleylu.com/2020/02/10/Navicat%E5%AE%89%E8%A3%85/"/>
    <id>http://mckinleylu.com/2020/02/10/Navicat%E5%AE%89%E8%A3%85/</id>
    <published>2020-02-10T06:21:53.000Z</published>
    <updated>2020-04-13T09:08:49.397Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天破解Navicat15，本来想申请学生教育免费，结果两天后客服告诉我需要学生邮箱，可惜没有.edu.cn邮箱，无奈只好破解。<a id="more"></a>  </p><h3 id="软件相关链接"><a href="#软件相关链接" class="headerlink" title="软件相关链接"></a>软件相关链接</h3><p><a href="https://www.navicat.com.cn/" target="_blank" rel="noopener">Navicat Premium15中文版</a></p><p><a href="https://www.lanzous.com/i97n2xe" target="_blank" rel="noopener">注册机</a></p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol><li><p>正版软件安装时候要断网</p></li><li><p>安装完成后不要打来</p></li><li><p>之后把注册机粘贴到软件安装目录下</p></li><li><p>打开注册机，点击”patch”按钮，成功的话会弹出对框“navicat.exe-x64-&gt;Cracked!”字样。</p><p><img src="/images/202001.jpg" style=" margin:0 auto;  "></p></li><li><p>现在运行Nacicat,会弹出窗口提示你只能用14天，这时候点击“注册”，点了之后要你输入激活码的窗口。回到注册机，点“Generate”,复制激活码，输入到软件中，点击确认</p><p><img src="/images/202002.jpg" style=" margin:0 auto;  "></p></li><li><p>这时候软件会弹出由于没网，这时点击“手动注册”</p></li><li><p>下一个界面里会有一大段的”请求码“，复制下来粘贴到注册机里，并点击最下方的”Generate“按钮，会生成注册码，复制回去激活即可。</p><p><img src="/images/202003.jpg" style=" margin:0 auto;  "></p></li><li><p>好好享受吧！</p><p><img src="/images/202005.jpg" style=" margin:0 auto;  "></p></li></ol><h3 id="谢谢访问"><a href="#谢谢访问" class="headerlink" title="谢谢访问"></a>谢谢访问</h3><div style=" width:747px; height: 447px; margin:0 auto">   <img src="/images/thank.jpg" style=" margin:0 auto;  ">  </div>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;今天破解Navicat15，本来想申请学生教育免费，结果两天后客服告诉我需要学生邮箱，可惜没有.edu.cn邮箱，无奈只好破解。
    
    </summary>
    
    
      <category term="软件安装" scheme="http://McKinleyLu.com/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
    
      <category term="Navicat15安装" scheme="http://McKinleyLu.com/tags/Navicat15%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>序列求和</title>
    <link href="http://mckinleylu.com/2019/12/31/%E5%BA%8F%E5%88%97%E6%B1%82%E5%92%8C/"/>
    <id>http://mckinleylu.com/2019/12/31/%E5%BA%8F%E5%88%97%E6%B1%82%E5%92%8C/</id>
    <published>2019-12-31T02:07:19.000Z</published>
    <updated>2019-12-31T03:18:27.830Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>求1+2+3+…+n的值。<a id="more"></a></p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入包括一个整数n。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一行，包括一个整数，表示1+2+3+…+n的值。</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><p>4</p><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><p>10</p><h4 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h4><p>100</p><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><p>5050</p><h3 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h3><p>1 &lt;= n &lt;= 1,000,000,000。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p> 计算1 … n的和</p><p>  注意，递归一定暴栈，循环一定超时</p><p>  要使用数学公式对其进行归纳</p><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span>  n = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span> ;</span><br><span class="line">   <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;sum = n /<span class="number">2</span> * n + n / <span class="number">2</span>;&#125;</span><br><span class="line">   <span class="keyword">else</span>            &#123;sum = n/<span class="number">2</span> * n + n;&#125;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; sum ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="蓝桥杯初级题目总结"><a href="#蓝桥杯初级题目总结" class="headerlink" title="蓝桥杯初级题目总结"></a>蓝桥杯初级题目总结</h3><p>  1.不要使用递归，必须使用动规</p><p>  2.注意每个题都极大可能有其对应数学公式(即一定有优化部分),否则一定超时</p><h3 id="谢谢访问"><a href="#谢谢访问" class="headerlink" title="谢谢访问"></a>谢谢访问</h3><div style=" width:747px; height: 447px; margin:0 auto">   <img src="/images/thank.jpg" style=" margin:0 auto;  ">  </div>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;求1+2+3+…+n的值。
    
    </summary>
    
    
      <category term="蓝桥杯" scheme="http://McKinleyLu.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
      <category term="竞赛" scheme="http://McKinleyLu.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="初级" scheme="http://McKinleyLu.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%AB%9E%E8%B5%9B/%E5%88%9D%E7%BA%A7/"/>
    
    
      <category term="算法" scheme="http://McKinleyLu.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="C++" scheme="http://McKinleyLu.com/tags/C/"/>
    
      <category term="蓝桥杯" scheme="http://McKinleyLu.com/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
      <category term="初级" scheme="http://McKinleyLu.com/tags/%E5%88%9D%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>圆的面积</title>
    <link href="http://mckinleylu.com/2019/12/31/%E5%9C%86%E7%9A%84%E9%9D%A2%E7%A7%AF/"/>
    <id>http://mckinleylu.com/2019/12/31/%E5%9C%86%E7%9A%84%E9%9D%A2%E7%A7%AF/</id>
    <published>2019-12-31T02:04:18.000Z</published>
    <updated>2019-12-31T03:18:25.098Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定圆的半径r，求圆的面积。<a id="more"></a></p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入包含一个整数r，表示圆的半径。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一行，包含一个实数，四舍五入保留小数点后7位，表示圆的面积。</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><p>4</p><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><p>50.2654825</p><h4 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><p>1 &lt;= r &lt;= 10000。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一定要记住Π的求法公式</p><p>double PI=atan(1.0)*4;</p><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> PI=<span class="built_in">atan</span>(<span class="number">1.0</span>)*<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; r ;</span><br><span class="line">    <span class="keyword">double</span> result = <span class="number">0</span> ;</span><br><span class="line">    result = PI*r*r;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%0.7f"</span>,result);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="谢谢访问"><a href="#谢谢访问" class="headerlink" title="谢谢访问"></a>谢谢访问</h3><div style=" width:747px; height: 447px; margin:0 auto">   <img src="/images/thank.jpg" style=" margin:0 auto;  ">  </div>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给定圆的半径r，求圆的面积。
    
    </summary>
    
    
      <category term="蓝桥杯" scheme="http://McKinleyLu.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
      <category term="竞赛" scheme="http://McKinleyLu.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="初级" scheme="http://McKinleyLu.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%AB%9E%E8%B5%9B/%E5%88%9D%E7%BA%A7/"/>
    
    
      <category term="算法" scheme="http://McKinleyLu.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="C++" scheme="http://McKinleyLu.com/tags/C/"/>
    
      <category term="蓝桥杯" scheme="http://McKinleyLu.com/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
      <category term="初级" scheme="http://McKinleyLu.com/tags/%E5%88%9D%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>Fibonacci数列</title>
    <link href="http://mckinleylu.com/2019/12/31/Fibonacci%E6%95%B0%E5%88%97/"/>
    <id>http://mckinleylu.com/2019/12/31/Fibonacci%E6%95%B0%E5%88%97/</id>
    <published>2019-12-31T01:56:48.000Z</published>
    <updated>2020-02-10T07:34:59.907Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Fibonacci数列的递推公式为：Fn=Fn-1+Fn-2，其中F1=F2=1。</p><p>当n比较大时，Fn也非常大，现在我们想知道，Fn除以10007的余数是多少。<a id="more"></a></p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p> 输入包含一个整数n。 </p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p> 输出一行，包含一个整数，表示Fn除以10007的余数。 </p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><p>10</p><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><p>55</p><h4 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h4><p>22</p><h4 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h4><p>7704</p><h4 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><p>1 &lt;= n &lt;= 1,000,000。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>归会暴栈，如果求出最后的F[N]，则F[N]已经溢出，故需要利用动态规划+等价类</p><p>公式：</p><p>  dp[1] = 1 ; dp[2]= 1 ;</p><p>  for(int i = 3 ; i &lt;= n ; ++i) {dp[i] = (dp[i-1] + dp[i-2])%10007;</p><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> n = <span class="number">0</span> ;</span><br><span class="line">   <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n+<span class="number">1</span>);</span><br><span class="line">   dp[<span class="number">1</span>] = <span class="number">1</span> ; dp[<span class="number">2</span>]= <span class="number">1</span> ;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span> ; i &lt;= n ; ++i) &#123;dp[i] = (dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>])%<span class="number">10007</span>;&#125;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; dp[n];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="谢谢访问"><a href="#谢谢访问" class="headerlink" title="谢谢访问"></a>谢谢访问</h3><div style=" width:747px; height: 447px; margin:0 auto">   <img src="/images/thank.jpg" style=" margin:0 auto;  ">  </div>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Fibonacci数列的递推公式为：Fn=Fn-1+Fn-2，其中F1=F2=1。&lt;/p&gt;
&lt;p&gt;当n比较大时，Fn也非常大，现在我们想知道，Fn除以10007的余数是多少。
    
    </summary>
    
    
      <category term="蓝桥杯" scheme="http://McKinleyLu.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
      <category term="竞赛" scheme="http://McKinleyLu.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="初级" scheme="http://McKinleyLu.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E7%AB%9E%E8%B5%9B/%E5%88%9D%E7%BA%A7/"/>
    
    
      <category term="算法" scheme="http://McKinleyLu.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="C++" scheme="http://McKinleyLu.com/tags/C/"/>
    
      <category term="蓝桥杯" scheme="http://McKinleyLu.com/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
      <category term="初级" scheme="http://McKinleyLu.com/tags/%E5%88%9D%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>Banch_limit_Tsp</title>
    <link href="http://mckinleylu.com/2019/11/23/Banch-limit-Tsp/"/>
    <id>http://mckinleylu.com/2019/11/23/Banch-limit-Tsp/</id>
    <published>2019-11-23T01:56:46.000Z</published>
    <updated>2019-11-23T03:01:50.974Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p><strong>设有n个城市，城市之间道路的长度均大于或等于0，还可能是∞（对应城市之间无交通线路）。一个旅行商从某个城市出发，要经过每个城市一次且仅一次，最后回到出发的城市，问他如何走才能使他走的路线最短？</strong></p><p><strong>要求：优先使用矩阵归约确定限界函数的方法，或者其他方法实现。</strong><a id="more"></a>  </p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p> <strong>对于这个问题，我们采用广度优先遍历，把从起点到其他未曾走过的边的权权入队(优先队列)</strong>。</p><p><strong>接下来每次从队中取出最小的权的元素，在其进行广度优先遍历，即从此点到其他未曾走过的边的权加上他本来的权的元素入队</strong></p><p><strong>结束条件，第一个所有节点都被访问过的元素被出队。</strong></p><p><strong>最后被出队元素在加上其最后一个被访问节点到起点的边的权</strong></p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>  <strong>首先从文件读取节点数量以及边数量、起点、边的权信息。所用时间T = O(n)</strong></p><p>  <strong>接着构造优先队列，所用时间</strong> <strong>T =</strong> <strong>O(nlogn)</strong></p><p>  <strong>接下来将起点到其他个点距离入队，所用时间T = (n-1)O(log n)</strong></p><p>  <strong>之后设置while循环，每次从队中取出最小的权的元素，进行广度优先遍历，将从此点到其他未曾走过的边的权加上他本来的权的元素入队。</strong></p><p><strong>所用时间T = O(n) (搜索未访问节点) + (n - deep)O(log n) (入队元素) +一次出队O(log n)</strong></p><p><strong>总时间约为T = O(nlogn)</strong></p><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> meter = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> pos   = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> v[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">&#125;ties;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(ties a, ties b) &#123;</span><br><span class="line">      <span class="keyword">return</span> a.meter &gt; b.meter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> buffer[<span class="number">200</span>];</span><br><span class="line">     <span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">"bandary_TSP.txt"</span>)</span></span>;</span><br><span class="line">     <span class="keyword">int</span> number = <span class="number">0</span> , side = <span class="number">0</span> , source = <span class="number">0</span>;</span><br><span class="line">     in.getline(buffer,<span class="number">20</span>);</span><br><span class="line">     <span class="built_in">sscanf</span>(buffer,<span class="string">"%d%d%d"</span>,&amp;number,&amp;side,&amp;source);</span><br><span class="line"></span><br><span class="line">     <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; v(number+<span class="number">1</span>);</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; v.size() ;++i) &#123;v[i].resize(number+<span class="number">1</span>);&#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= side    ;++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span> , n = <span class="number">0</span> , w = <span class="number">0</span>;</span><br><span class="line">        in.getline(buffer,<span class="number">20</span>);</span><br><span class="line">        <span class="built_in">sscanf</span>(buffer,<span class="string">"%d%d%d"</span>,&amp;m,&amp;n,&amp;w);</span><br><span class="line">        v[m][n] = w ;</span><br><span class="line">        v[n][m] = w ;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     priority_queue&lt;ties&gt; q;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= number ; ++i)&#123;</span><br><span class="line">     <span class="keyword">if</span>(i != source) &#123;</span><br><span class="line">     ties temp ;</span><br><span class="line">     temp.meter = v[source][i];</span><br><span class="line">     temp.v[source]  = <span class="number">1</span> ;</span><br><span class="line">     temp.pos   = i ;</span><br><span class="line">     temp.cnt += <span class="number">1</span> ;</span><br><span class="line">     q.push(temp);</span><br><span class="line">     &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">     ties temp = q.top();</span><br><span class="line">        temp.cnt += <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">if</span>(temp.cnt + <span class="number">1</span> == number)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ;i &lt;= number ; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp.v[i] != <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; temp.meter+v[temp.pos][i];</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= number ; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.v[i] != <span class="number">1</span> &amp;&amp; i != temp.pos )&#123;</span><br><span class="line">        temp.meter += v[temp.pos][i];</span><br><span class="line">         temp.v[temp.pos]  = <span class="number">1</span>;</span><br><span class="line">        temp.v[i]  = <span class="number">1</span>;</span><br><span class="line">        temp.pos   = i ;</span><br><span class="line">        q.push(temp)   ;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h3 id="谢谢访问"><a href="#谢谢访问" class="headerlink" title="谢谢访问"></a>谢谢访问</h3><div style=" width:747px; height: 447px; margin:0 auto">   <img src="/images/thank.jpg" style=" margin:0 auto;  ">  </div>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;设有n个城市，城市之间道路的长度均大于或等于0，还可能是∞（对应城市之间无交通线路）。一个旅行商从某个城市出发，要经过每个城市一次且仅一次，最后回到出发的城市，问他如何走才能使他走的路线最短？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;要求：优先使用矩阵归约确定限界函数的方法，或者其他方法实现。&lt;/strong&gt;
    
    </summary>
    
    
      <category term="算法课下实验" scheme="http://McKinleyLu.com/categories/%E7%AE%97%E6%B3%95%E8%AF%BE%E4%B8%8B%E5%AE%9E%E9%AA%8C/"/>
    
      <category term="Banch_limit_Tsp" scheme="http://McKinleyLu.com/categories/%E7%AE%97%E6%B3%95%E8%AF%BE%E4%B8%8B%E5%AE%9E%E9%AA%8C/Banch-limit-Tsp/"/>
    
    
      <category term="算法" scheme="http://McKinleyLu.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Banch_limit_0-1pacage</title>
    <link href="http://mckinleylu.com/2019/11/23/Banch-limit-0-1pacage/"/>
    <id>http://mckinleylu.com/2019/11/23/Banch-limit-0-1pacage/</id>
    <published>2019-11-23T01:42:15.000Z</published>
    <updated>2019-12-31T03:03:16.638Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p> <strong>0-1背包问题</strong></p><p><strong>已知n个物品的价值vi和重量wi，背包的载重W，求能放入背包的最大价值。用分支限界方法解决此问题</strong><a id="more"></a>  </p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p><strong>该背包是0-1背包，只有背包里的物品放与不放两种选择。在本题中，题目要求使用分支限界方法求解。故需要确定一下背包放物品的上界以及下界。</strong></p><p>   <strong>求上界：</strong></p><p>​    <strong>即比背包放的实际最大价值要大。</strong></p><p>​    <strong>计算方法：max(物品单位重量最大值) 背包容积</strong></p><p>​    <strong>求下界：</strong></p><p>​    <strong>在这里我们使用贪心算法，求得放入背包的物品价值最少不能低于该值</strong></p><p>​    <strong>计算方法：优先选择价值高的物品放入，直到背包不能再放入任何其他物品</strong></p><p>   <strong>确定上下界以后，对背包每个物品分放与不放两种情况分析：</strong></p><p>   <strong>放：则要注意放入后的背包所剩体积(c – w )要大于零，否则不放。</strong></p><p>​      <strong>若能放入，则有</strong> </p><p>​      <strong>w=w+goods.weight</strong></p><p>​      <strong>v = v +goods.value</strong></p><p>​       <strong>vb = v + (剩余没放的物品中物品单位重量最大值)剩余背包容量</strong></p><p>​      <strong>vb用于时刻计算物品背包当前状态下到最后的最大价值</strong></p><p>​      <strong>若vb值不小于由贪心算法求得的下界，则入队，否则不入队</strong></p><p>​    <strong>不放：</strong></p><p>​       <strong>则需要更新此时情况的最大上界</strong></p><p>​      <strong>vb = v + (剩余没放的物品中物品单位重量最大值)剩余背包容量</strong></p><p>​       <strong>若vb值不小于由贪心算法求得的下界，则入队，否则不入队</strong></p><p>​    <strong>出口条件：</strong></p><p>​      <strong>出队元素的w足够大，以至于不能放入任何物品</strong></p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p><strong>首先从文件读取背包以及物品信息。所用时间T = O(n)</strong></p><p> <strong>其次使用贪心算法求出物品下界，需要对物品按照价值做降序的快速排序，然后再使用一重循环，计算好下界。所用时间T = O(nlogn) + O(n) = O(nlogn)</strong></p><p><strong>之后使用优先队列，优先队列设置为大顶堆，每次弹出此时背包实际价值最大的元素出队，进行放与不放的操作。</strong></p><p><strong>由于优先队列用堆来实现，具有O(log n)时间复杂度的插入元素性能，O(n)的初始化构造的时间复杂度。插入与删除的时间复杂度为O(log n)，构造二叉树的时间复杂度为O(n log n)</strong></p><p><strong>所以此步的时间复杂度大概为T =O(nlogn) +O(logn)约等于O(nlogn)*</strong></p><p><strong>最终该算法时间复杂度为T =O(n)+ O(nlogn) +O(nlogn)约等于O(nlogn)</strong></p><h3 id="分支限界的认识"><a href="#分支限界的认识" class="headerlink" title="分支限界的认识"></a>分支限界的认识</h3><ol><li><p><strong>以广度优先或以最小耗费（最大效益）优先的方式搜索问题的解空间树</strong></p></li><li><p><strong>分支限界法中，每一个活结点只有一次机会成为扩展结点，活结点一旦成为扩展结点，就一次性产生其所有儿子结点，其中导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被加入活结点表中</strong></p></li><li><p><strong>然后从活结点表中取下一结点成为当前扩展结点</strong></p></li><li><p><strong>重复上述结点扩展过程，直至到找到所需的解或活结点表为空时为止</strong></p></li></ol><h3 id="分支限界与回溯法区别"><a href="#分支限界与回溯法区别" class="headerlink" title="分支限界与回溯法区别"></a><strong>分支限界与回溯法区别</strong></h3><ol><li><p><strong>求解目标不同</strong></p><p><strong>回溯法的求解目标是找出解空间树中满足约束条件的所有解</strong></p><p><strong>分支限界法的求解目标则是尽快找出满足约束条件的一个解，或是在满足约束条件的解中找出在某种意义下的最优解</strong></p></li><li><p><strong>搜索方式不同</strong></p><p><strong>回溯法以深度优先的方式（遍历结点）搜索解空间树</strong></p><p><strong>分支限界法以广度优先或最小耗费优先的方式搜索解空间树</strong></p></li><li><p><strong>对扩展结点的扩展方式不同</strong></p><p><strong>分支限界法中，每一个活结点只有一次机会成为扩展结点活结点一旦成</strong> <strong>为扩展结点，就一次性产生其所有儿子结点</strong></p></li><li><p><strong>存储空间的要求不同</strong></p><p><strong>分支限界法的存储空间比回溯法大得多，因此当内存容量有限时，回溯法成</strong> <strong>功的可能性更大</strong></p></li></ol><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">double</span>  value =  <span class="number">0.00</span>;</span><br><span class="line"><span class="keyword">double</span>  weight = <span class="number">0.00</span>;</span><br><span class="line"><span class="keyword">double</span>  pervalue = <span class="number">0.00</span>;</span><br><span class="line">&#125;goods;</span><br><span class="line"><span class="comment">//---------------------------</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">     <span class="keyword">double</span> w = <span class="number">0</span> ;</span><br><span class="line">     <span class="keyword">double</span> v = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">double</span> vb = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span>    next = <span class="number">0</span>;</span><br><span class="line">&#125;point;</span><br><span class="line"><span class="comment">//-------------------------</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(point a, point b) &#123;</span><br><span class="line">      <span class="keyword">return</span> a.v &gt; b.v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//----------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(goods a , goods b)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(a.pervalue == b.pervalue)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.weight &lt; b.weight;</span><br><span class="line">      &#125;</span><br><span class="line"> <span class="keyword">return</span> a.pervalue &gt; b.pervalue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//file operate</span></span><br><span class="line">     <span class="keyword">char</span> buffer[<span class="number">200</span>];</span><br><span class="line">     <span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">"0-1pacage.txt"</span>)</span></span>;</span><br><span class="line">     <span class="keyword">int</span> number = <span class="number">0</span> , c = <span class="number">0</span> ;</span><br><span class="line">     in.getline(buffer,<span class="number">20</span>);</span><br><span class="line">     <span class="built_in">sscanf</span>(buffer,<span class="string">"%d%d"</span>,&amp;number,&amp;c);</span><br><span class="line"></span><br><span class="line">     <span class="built_in">vector</span>&lt;goods&gt; v(number+<span class="number">1</span>) ;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; v.size() ; ++i)&#123;</span><br><span class="line">     <span class="keyword">double</span> value = <span class="number">0</span> , weight = <span class="number">0</span> ;</span><br><span class="line">     in.getline(buffer,<span class="number">20</span>);</span><br><span class="line">     <span class="built_in">sscanf</span>(buffer,<span class="string">"%lf%lf"</span>,&amp;weight,&amp;value);</span><br><span class="line">     v[i].value  = value;</span><br><span class="line">     v[i].weight = weight;</span><br><span class="line">     v[i].pervalue = v[i].value/v[i].weight;</span><br><span class="line">     &#125;</span><br><span class="line">     sort(v.begin()+<span class="number">1</span>,v.end(),cmp);</span><br><span class="line">    <span class="comment">//max</span></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span> ;</span><br><span class="line">    max = v[<span class="number">1</span>].pervalue*c;</span><br><span class="line">    <span class="comment">//min</span></span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">0</span> ,tmp = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= v.size() ; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp + v[i].weight &lt;= c)&#123;</span><br><span class="line">            tmp += v[i].weight;</span><br><span class="line">            min += v[i].value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>    &#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//main</span></span><br><span class="line">    priority_queue&lt;point&gt; q;</span><br><span class="line">      point init;</span><br><span class="line">      init.w = <span class="number">0</span> ,init.v = <span class="number">0</span>,init.vb = max , init.next = <span class="number">1</span>;</span><br><span class="line">      q.push(init);</span><br><span class="line">      <span class="keyword">double</span> value = <span class="number">0</span> ;</span><br><span class="line">      <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        point m = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(value &lt; m.v) &#123;value = m.v;&#125;</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// cout &lt;&lt; m.v &lt;&lt;" "&lt;&lt; m.vb&lt;&lt;" "&lt;&lt;m.w&lt;&lt;" "&lt;&lt;m.next&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">          <span class="keyword">if</span>(m.next != number+<span class="number">1</span>)&#123;</span><br><span class="line">                  <span class="comment">//不加</span></span><br><span class="line">             <span class="keyword">double</span> s = m.v + (c - m.w)*v[m.next+<span class="number">1</span>].pervalue;</span><br><span class="line">             <span class="keyword">if</span>(s &gt;= min) &#123;</span><br><span class="line">               point add;</span><br><span class="line">               add.w = m.w;  add.v = m.v ; add.vb = s; add.next = m.next + <span class="number">1</span> ;</span><br><span class="line">               q.push(add);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//加</span></span><br><span class="line">             <span class="comment">//判断是否可以加</span></span><br><span class="line">               <span class="keyword">if</span>(m.w + v[m.next].weight &lt;= c)&#123;</span><br><span class="line">               point add;</span><br><span class="line">               add.w = m.w + v[m.next].weight;</span><br><span class="line">               add.v = m.v + v[m.next].value;</span><br><span class="line">               add.next = m.next + <span class="number">1</span> ;</span><br><span class="line">               add.vb = add.v + (c - add.w)*v[add.next].pervalue;</span><br><span class="line">               <span class="keyword">if</span>(add.vb &lt; min) &#123;<span class="keyword">continue</span>;&#125;</span><br><span class="line">               q.push(add);</span><br><span class="line">               &#125;</span><br><span class="line">       &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; value;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="谢谢访问"><a href="#谢谢访问" class="headerlink" title="谢谢访问"></a>谢谢访问</h3><div style=" width:747px; height: 447px; margin:0 auto">   <img src="/images/thank.jpg" style=" margin:0 auto;  ">  </div>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;p&gt; &lt;strong&gt;0-1背包问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;已知n个物品的价值vi和重量wi，背包的载重W，求能放入背包的最大价值。用分支限界方法解决此问题&lt;/strong&gt;
    
    </summary>
    
    
      <category term="算法课下实验" scheme="http://McKinleyLu.com/categories/%E7%AE%97%E6%B3%95%E8%AF%BE%E4%B8%8B%E5%AE%9E%E9%AA%8C/"/>
    
      <category term="Banch_limit_0-1pacage" scheme="http://McKinleyLu.com/categories/%E7%AE%97%E6%B3%95%E8%AF%BE%E4%B8%8B%E5%AE%9E%E9%AA%8C/Banch-limit-0-1pacage/"/>
    
    
      <category term="算法" scheme="http://McKinleyLu.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>temp</title>
    <link href="http://mckinleylu.com/2019/11/21/temp/"/>
    <id>http://mckinleylu.com/2019/11/21/temp/</id>
    <published>2019-11-21T12:49:23.000Z</published>
    <updated>2019-11-23T02:56:04.062Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p><strong>邮票问题</strong></p><p><strong>设有已知面额的邮票m种，每种有n张，问用总数不超过n张的邮票进行组合，能组合的邮票面额中可以连续的面额数最多有多少？</strong><a id="more"></a>  </p><p><strong>例如：n=4  m=3</strong></p><p><strong>面额分别为：v1=1   v2=2  v3=4</strong></p><p>   <strong>最后的解为14。</strong></p><p><strong>请设计回溯算法求解以上问题，分析算法的时间复杂度；利用C语言实现，要求结果正确。</strong></p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p> <strong>首先要读懂题意：即给的邮票能组合成最大的连续数字是多少。</strong></p><p>  <strong>我们不妨假设它可以组合成连续的正无穷的数字。接下来，我们从1数字开始尝试看所给邮票能不能组合而成，显然这是一个for循环。如果一旦不能组合而成，则返回数字减1，即为最大所能组合而成的邮票最大值。</strong></p><h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h3><p><strong>首先从文件里读出邮票种类以及其面值、可用邮票数量。</strong></p><p>  <strong>接下来，我们设置一个没有边界的循环，目的是探究最大连续数字是多少</strong></p><p>  <strong>之后利用回溯方法：</strong></p><p>   <strong>尝试每次所选的票的面值，目的是使所有票面值之和为外层假设的最大票数。</strong></p><p><strong>部分解：如果加入该票后，总的票的面额没有大于外层假设的最大票数。如果不是，则需要进一步循环尝试</strong></p><p><strong>合法解：如果在该票为部分解的前提下，总的票的面额没有大于外层假设的等于票数，此时跳出双重while的回溯算法，继续增加外层假设的最大票数面值之和。</strong></p><p><strong>当使用回溯法时，发现对于某个连续的最大票数面值之和没有找到合法解，则该最大票数面值之和减一即为最大连续票数面值之和。</strong></p><p><strong>时间复杂度：</strong></p><p> <strong>两个while回溯循环T= O(n^n)</strong></p><p> <strong>再加上最外层for循环T = On\^(n+1)）= O(n^n)</strong></p><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">220</span>];</span><br><span class="line">    <span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">"Temp.txt"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span> , n = <span class="number">0</span>;</span><br><span class="line">    in.getline(buffer,<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">sscanf</span>(buffer,<span class="string">"%d%d"</span>,&amp;m,&amp;n);</span><br><span class="line">    <span class="comment">//邮票价值从小输入</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(m+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> max_value = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; v.size() ; ++i)&#123;</span><br><span class="line">        in.getline(buffer,<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">int</span> temp =  <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sscanf</span>(buffer,<span class="string">"%d"</span>,&amp;temp);</span><br><span class="line">        v[i] = temp;</span><br><span class="line">        <span class="keyword">if</span>(max_value &lt; temp)&#123;max_value = temp;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; ; ++i)&#123;</span><br><span class="line">     <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span> ;  k&lt;=n ; ++k)&#123;</span><br><span class="line">             c[k] = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span>(k &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">while</span>(c[k] &lt; max_value &amp;&amp; k&lt;= n)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; v.size() ; ++j) &#123;<span class="keyword">if</span>(v[j] &gt; c[k]) &#123;c[k] = v[j]; <span class="keyword">break</span>;&#125;&#125;</span><br><span class="line">       <span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line">                 <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">1</span> ;a &lt; c.size() ; ++a) &#123;sum += c[a];&#125;</span><br><span class="line">                 <span class="comment">//cout &lt;&lt; sum&lt;&lt;i &lt;&lt; " ";</span></span><br><span class="line">       <span class="keyword">if</span>(sum == i) &#123;flag = <span class="literal">true</span> ;<span class="keyword">break</span>;&#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; i) &#123;k += <span class="number">1</span> ;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">          <span class="keyword">if</span>(flag) &#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">          c[k] = <span class="number">0</span> ;</span><br><span class="line">          k -= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(flag) &#123;<span class="keyword">continue</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span>     &#123;--i;<span class="built_in">cout</span> &lt;&lt; i ; <span class="keyword">break</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="谢谢访问"><a href="#谢谢访问" class="headerlink" title="谢谢访问"></a>谢谢访问</h3><div style=" width:747px; height: 447px; margin:0 auto">   <img src="/images/thank.jpg" style=" margin:0 auto;  ">  </div>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;邮票问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设有已知面额的邮票m种，每种有n张，问用总数不超过n张的邮票进行组合，能组合的邮票面额中可以连续的面额数最多有多少？&lt;/strong&gt;
    
    </summary>
    
    
      <category term="算法课下实验" scheme="http://McKinleyLu.com/categories/%E7%AE%97%E6%B3%95%E8%AF%BE%E4%B8%8B%E5%AE%9E%E9%AA%8C/"/>
    
      <category term="color" scheme="http://McKinleyLu.com/categories/%E7%AE%97%E6%B3%95%E8%AF%BE%E4%B8%8B%E5%AE%9E%E9%AA%8C/color/"/>
    
    
      <category term="算法" scheme="http://McKinleyLu.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>color</title>
    <link href="http://mckinleylu.com/2019/11/21/color/"/>
    <id>http://mckinleylu.com/2019/11/21/color/</id>
    <published>2019-11-21T12:43:45.000Z</published>
    <updated>2019-11-21T13:53:27.884Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p><strong>3-着色问题</strong></p><p><strong>判定无向图G=（V,E）是否可以用3种颜色着色，可以，请给出着色方案。</strong><a id="more"></a>  </p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>  <strong>处理三色问题，我们要考虑到每条边的两个端点颜色需要不同。</strong></p><p><strong>采用回溯的方法，对每种结果进行尝试，如果当前颜色不能满足约束条件，则换一种颜色，如果任何颜色尝试任何颜色后，都不满足约束条件，则需要向后退，k&lt;- k-1,同时把尝试颜色的点的颜色清空(c[k] = 0 ) .</strong></p><p>  <strong>如果尝试的颜色满足约束条件，则判断它是否满足解的条件，如果满足，则输出相应颜色分布。否则，则可能为部分解，接下来尝试下一个节点颜色。</strong></p><h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h3><p><strong>首先使用按行读文件的方式，从文件获取顶点个数、边的个数以及相应的两</strong> <strong>个顶点之间有边。</strong>   <strong>所花时间为线性时间T = O(n)</strong></p><p>   <strong>接下来初始化二维数组，若两结点没有边，则边的权值为正无穷。否则为边的文件输入的边的权所花时间T = O(n^2)</strong></p><p>  <strong>接下来为核心算法：</strong></p><p>​    <strong>首先构造一维数组，一维数组值为颜色，0代表没有涂颜色。</strong></p><p>​    <strong>接下来开始从第一节点开始确定其颜色，通过加一向该节点涂颜色。如果涂上某颜色后，需要判断是否与其他节点颜色冲突。</strong> <strong>判断所花时间为线性时间**</strong>T = O(n)**</p><p>​    <strong>接下来在判断是否满足解空间。如果最后一个节点是部分解(有颜色且不与任何节点颜色冲突)，则是解空间的一个解。此判断所花时间为线性时间T = O(1)，之后直接退出双层循环即可</strong></p><p>  <strong>如果图的解空间为空，则需要两层whlie循环需要时间为O(number^color)</strong></p><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 999</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;c)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> len = c.size();</span><br><span class="line">      --len;</span><br><span class="line">      <span class="keyword">if</span>(c[len] != <span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; v,<span class="keyword">int</span> k,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ;i &lt; v.size() ; ++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(v[k][i] != INF)&#123;</span><br><span class="line"><span class="keyword">if</span>(c[k] == c[i])&#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">220</span>];</span><br><span class="line">    <span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">"Three_color.txt"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">0</span>,color= <span class="number">0</span>,sidenumber = <span class="number">0</span> ;</span><br><span class="line">    in.getline(buffer,<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">sscanf</span>(buffer,<span class="string">"%d%d%d"</span>,&amp;number,&amp;color,&amp;sidenumber);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; v(number+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; v.size() ; ++i)&#123;</span><br><span class="line">    v[i].resize(number+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; v.size() ; ++i)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; v[i].size(); ++j)&#123;</span><br><span class="line">    v[i][j] = INF;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i&lt;= sidenumber ; ++i)&#123;</span><br><span class="line">    in.getline(buffer,<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span> , n = <span class="number">0</span> ,w = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sscanf</span>(buffer,<span class="string">"%d%d%d"</span>,&amp;m,&amp;n,&amp;w);</span><br><span class="line">    v[m][n] = w ;</span><br><span class="line">    v[n][m] = w ;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c(number+<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= number ; ++k)&#123;</span><br><span class="line">      c[k] = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">int</span>  k = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span> ;</span><br><span class="line">    <span class="keyword">while</span>(k &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">while</span>(c[k] &lt;= color &amp;&amp; k &lt;= number)&#123;</span><br><span class="line">      c[k] += <span class="number">1</span> ;</span><br><span class="line">           <span class="keyword">if</span>(judge(v,k,c))&#123;</span><br><span class="line">                <span class="keyword">if</span>(solve(c))&#123; flag = <span class="literal">true</span> ; <span class="keyword">break</span>;&#125;</span><br><span class="line">                k += <span class="number">1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="keyword">if</span>(flag)&#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">     c[k] = <span class="number">0</span> ;</span><br><span class="line">     k -= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!flag)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"no solution !"</span> ;&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; c.size() ; ++i) &#123;<span class="built_in">cout</span>&lt;&lt;c[i]&lt;&lt;<span class="string">" "</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="谢谢访问"><a href="#谢谢访问" class="headerlink" title="谢谢访问"></a>谢谢访问</h3><div style=" width:747px; height: 447px; margin:0 auto">   <img src="/images/thank.jpg" style=" margin:0 auto;  ">  </div>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;3-着色问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;判定无向图G=（V,E）是否可以用3种颜色着色，可以，请给出着色方案。&lt;/strong&gt;
    
    </summary>
    
    
      <category term="算法课下实验" scheme="http://McKinleyLu.com/categories/%E7%AE%97%E6%B3%95%E8%AF%BE%E4%B8%8B%E5%AE%9E%E9%AA%8C/"/>
    
      <category term="color" scheme="http://McKinleyLu.com/categories/%E7%AE%97%E6%B3%95%E8%AF%BE%E4%B8%8B%E5%AE%9E%E9%AA%8C/color/"/>
    
    
      <category term="算法" scheme="http://McKinleyLu.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Base TSP</title>
    <link href="http://mckinleylu.com/2019/11/10/Base-TSP/"/>
    <id>http://mckinleylu.com/2019/11/10/Base-TSP/</id>
    <published>2019-11-10T07:13:52.000Z</published>
    <updated>2019-11-21T13:48:53.133Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>已知图G=(V,E)，利用贪心策略求解图G上的从顶点1出发的最短巡回旅行路线，要求输出找到的(近似)最短巡回旅行路线。</p><p>要求：给出问题的贪心算法，并编程实现<a id="more"></a>  </p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p><strong>本题类似邮递员问题，从图中任意一个出发，首先寻找起始点到所有点距离最近</strong>  <strong>的点，找到后，新的点再找离它最近的点，知道回到出发点，即位所求最短路径。这种思路显然为贪心思路。简洁总结如下：</strong></p><ol><li><strong>从某个城市开始，每次选择一个城市，知道所有的城市都被走完</strong></li><li><strong>每次只选择到下一个城市最近的路线所对应的城市</strong></li></ol><p><img src="/images/saunfa3-2.jpg" style=" margin:0 auto;  "></p><h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h3><p><strong>(1)</strong>  <strong>从文件读入内存数据，时间复杂度为线性O(n)</strong></p><p><strong>(2)</strong>  <strong>邻接矩阵储存顶点之间的边的长度。</strong></p><p><strong>(3)</strong>  <strong>使用双重循环，从起点开始，依次找到最短路径上的顶点：</strong></p><p><strong>具体思路如下：</strong></p><p><strong>开始时X = {起点a}，Y = {顶点b，顶点c，顶点d}</strong></p><p><strong>确定起点到另外三个顶点中最短的一个顶点路径，并将b号顶点加入X集合，此时X ={a,b}</strong>，<strong>Y ={c,d}</strong></p><p><strong>按照每次只加入离当前顶点最近的顶点，知道Y集合为空。</strong></p><p>   <strong>时间复杂度为O(n^2)</strong></p><p>   <strong>综上所述，时间复杂度为O(n^2)</strong></p><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEN 99999</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">greedy</span><span class="params">(<span class="keyword">int</span> start_city,<span class="keyword">const</span> <span class="keyword">int</span> number,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;city, <span class="keyword">const</span> <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; length )</span></span>&#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"TSP路线:"</span>  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      <span class="comment">//cout &lt;&lt; start_city &lt;&lt; "--&gt;";</span></span><br><span class="line">      <span class="keyword">int</span> start = start_city ;</span><br><span class="line">      <span class="keyword">int</span> next_city = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> sum_min = <span class="number">0</span> ;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= number ; ++i)&#123;</span><br><span class="line">          <span class="keyword">int</span> len = MAXLEN;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= number ; j++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(city[j] == <span class="number">1</span>)                  &#123;<span class="keyword">continue</span>;&#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span>(len &gt; length[start_city][j])  &#123;</span><br><span class="line">          len = length[start_city][j];</span><br><span class="line">          next_city = j ;</span><br><span class="line">          &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          start_city = next_city ;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;start_city&lt;&lt;<span class="string">"--&gt;"</span>;</span><br><span class="line">          city[start_city] = <span class="number">1</span>;</span><br><span class="line">          sum_min += len;</span><br><span class="line">      &#125;</span><br><span class="line">      sum_min += length[start_city][start] ;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; start &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> sum_min;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">200</span>];</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">0</span> ;            <span class="comment">//城市个数</span></span><br><span class="line">    <span class="keyword">int</span> edge   = <span class="number">0</span> ;            <span class="comment">//边个数</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; city(number+<span class="number">1</span>);   <span class="comment">// 记录城市已经路过</span></span><br><span class="line">    <span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">"tsp.txt"</span>)</span></span>;</span><br><span class="line">    in.getline(buffer,<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">sscanf</span>(buffer,<span class="string">"%d"</span>,&amp;number);</span><br><span class="line">    <span class="comment">// 构造二维数组</span></span><br><span class="line">    <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; length(number+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; length.size() ; ++i)&#123;length[i].resize(number+<span class="number">1</span>);&#125;</span><br><span class="line">    <span class="comment">//临界矩阵保存两点间路的长度</span></span><br><span class="line">       <span class="comment">//输入两点间的路径个数</span></span><br><span class="line">       in.getline(buffer,<span class="number">20</span>);</span><br><span class="line">       <span class="built_in">sscanf</span>(buffer,<span class="string">"%d"</span>,&amp;edge);</span><br><span class="line">       <span class="comment">//保存两点间路径长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= edge ; ++i)&#123;</span><br><span class="line">    in.getline(buffer,<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span> , n = <span class="number">0</span>  , w = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sscanf</span>(buffer,<span class="string">"%d%d%d"</span>,&amp;m,&amp;n,&amp;w);</span><br><span class="line">    length[m][n] = w ;</span><br><span class="line">    length[n][m] = w ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; length.size();++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; length.size(); ++j)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; length[i][j] &lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start_city = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">int</span> sum_min = <span class="number">0</span> ;</span><br><span class="line">    in.getline(buffer,<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">sscanf</span>(buffer,<span class="string">"%d"</span>,&amp;start_city);</span><br><span class="line">    sum_min = greedy(start_city,number,city,length);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"最短路径长度为: "</span> &lt;&lt; sum_min ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="谢谢访问"><a href="#谢谢访问" class="headerlink" title="谢谢访问"></a>谢谢访问</h3><div style=" width:747px; height: 447px; margin:0 auto">   <img src="/images/thank.jpg" style=" margin:0 auto;  ">  </div>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;p&gt;已知图G=(V,E)，利用贪心策略求解图G上的从顶点1出发的最短巡回旅行路线，要求输出找到的(近似)最短巡回旅行路线。&lt;/p&gt;
&lt;p&gt;要求：给出问题的贪心算法，并编程实现
    
    </summary>
    
    
      <category term="算法课下实验" scheme="http://McKinleyLu.com/categories/%E7%AE%97%E6%B3%95%E8%AF%BE%E4%B8%8B%E5%AE%9E%E9%AA%8C/"/>
    
      <category term="activity" scheme="http://McKinleyLu.com/categories/%E7%AE%97%E6%B3%95%E8%AF%BE%E4%B8%8B%E5%AE%9E%E9%AA%8C/activity/"/>
    
    
      <category term="算法" scheme="http://McKinleyLu.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>活动安排问题</title>
    <link href="http://mckinleylu.com/2019/11/10/%E6%B4%BB%E5%8A%A8%E5%AE%89%E6%8E%92%E9%97%AE%E9%A2%98/"/>
    <id>http://mckinleylu.com/2019/11/10/%E6%B4%BB%E5%8A%A8%E5%AE%89%E6%8E%92%E9%97%AE%E9%A2%98/</id>
    <published>2019-11-10T07:05:28.000Z</published>
    <updated>2019-11-10T08:22:15.306Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>设有n个活动的集合e={1，2，…，n}，其中每个活动都要求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。每个活动i都有一个要求使用该资源的起始时间si和一个结束时间fi,且si<fi。如果选择了活动i，则它在区间[si，fi]内占用资源。若区间[si，fi]与区间[sj，fj]不相交，则称活动i与活动j是相容的。也就是说，当sj≥fi或si≥fj时，活动i与活动j相容。活动安排问题就是要在所给的活动集合中选出最大的相容活动子集合。<a id="more"></a>  </fi。如果选择了活动i，则它在区间[si，fi]内占用资源。若区间[si，fi]与区间[sj，fj]不相交，则称活动i与活动j是相容的。也就是说，当sj≥fi或si≥fj时，活动i与活动j相容。活动安排问题就是要在所给的活动集合中选出最大的相容活动子集合。<!--more--></p><p>  要求：给出问题的贪心算法，并编程实现。</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p><strong>考虑到每个活动只能单独进行，且要活动越多越好，所以考虑使用贪心算法，使越早结束的活动排在前面，这样就保证了活动尽可能多。如果一个活动的开始在前一个活动结束时间之前，则去掉该活动，保证每个时刻只有一个活动在承办。</strong></p><p><strong>活动设置图(每一个小横线代表一个活动)</strong></p><p><img src="/images/suanfa3-1.jpg" style=" margin:0 auto;  "></p><h3 id="算法设计："><a href="#算法设计：" class="headerlink" title="算法设计："></a>算法设计：</h3><p><strong>(1)</strong>  <strong>储存方式：采用结构体储存方式，结构内包含一个活动开始以及结束时间。</strong></p><p><strong>(2)</strong>  <strong>使用文件方式从外存读取数据，费时为线性时间O(n)</strong></p><p><strong>(3)</strong>  <strong>对结构体数组进行以按照每个活动结束时间进行快速排序，所用时间复杂度为O(nlogn)</strong></p><p><strong>(4)</strong>  <strong>构建一维结构数组，将结束时间靠前且不与之前活动时间重叠的活动加入到数组。这里需要一个for循环，所需是时间为线性，所以时间复杂复杂度为O(n)</strong></p><p><strong>(5)</strong>  <strong>最后打印出输出活动序列，以及最大的活动数量。所需时间为线性时间O(n) + O(1)</strong></p><p><strong>综上所述，本算法时间复杂度为O(n)</strong></p><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">double</span> start;</span><br><span class="line"><span class="keyword">double</span> end;</span><br><span class="line"><span class="keyword">double</span> time;</span><br><span class="line">&#125;activity;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(activity a ,activity b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.end &lt; b.end ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">string_to_number</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(s)</span> </span>;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span> ;</span><br><span class="line">ss &gt;&gt; a ;</span><br><span class="line"><span class="keyword">return</span> a ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">char</span> buffer[<span class="number">250</span>];</span><br><span class="line">   <span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">"activity.txt"</span>)</span></span>;</span><br><span class="line">   <span class="keyword">int</span> number = <span class="number">0</span> ;</span><br><span class="line">   <span class="built_in">string</span> s ;</span><br><span class="line">   getline(in,s);</span><br><span class="line">   number = string_to_number(s);</span><br><span class="line">   s.clear();</span><br><span class="line">   <span class="built_in">vector</span>&lt;activity&gt; v(number);</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; number ; ++i )&#123;</span><br><span class="line">   in.getline(buffer,<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">sscanf</span>(buffer,<span class="string">"%lf%lf"</span>,&amp;v[i].start,&amp;v[i].end);</span><br><span class="line">    v[i].time = v[i].end - v[i].start;</span><br><span class="line">   &#125;</span><br><span class="line">   sort(v.begin(),v.end(),cmp);</span><br><span class="line">   <span class="built_in">vector</span>&lt;activity&gt; m ;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; v.size() ; ++i)&#123;</span><br><span class="line">     m.push_back(v[i]);</span><br><span class="line">     <span class="keyword">if</span>( i + <span class="number">1</span> == v.size()) &#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span> ; j &lt; v.size() ; ++j)&#123;</span><br><span class="line">     <span class="keyword">if</span>(v[j].start &gt;= v[i].end) &#123;i = j - <span class="number">1</span> ;<span class="keyword">break</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; m.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m.size() ;++i)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lf %lf\n"</span>,m[i].start,m[i].end);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="谢谢访问"><a href="#谢谢访问" class="headerlink" title="谢谢访问"></a>谢谢访问</h3><div style=" width:747px; height: 447px; margin:0 auto">   <img src="/images/thank.jpg" style=" margin:0 auto;  ">  </div>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;p&gt;设有n个活动的集合e={1，2，…，n}，其中每个活动都要求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。每个活动i都有一个要求使用该资源的起始时间si和一个结束时间fi,且si&lt;fi。如果选择了活动i，则它在区间[si，fi]内占用资源。若区间[si，fi]与区间[sj，fj]不相交，则称活动i与活动j是相容的。也就是说，当sj≥fi或si≥fj时，活动i与活动j相容。活动安排问题就是要在所给的活动集合中选出最大的相容活动子集合。
    
    </summary>
    
    
      <category term="算法课下实验" scheme="http://McKinleyLu.com/categories/%E7%AE%97%E6%B3%95%E8%AF%BE%E4%B8%8B%E5%AE%9E%E9%AA%8C/"/>
    
      <category term="activity" scheme="http://McKinleyLu.com/categories/%E7%AE%97%E6%B3%95%E8%AF%BE%E4%B8%8B%E5%AE%9E%E9%AA%8C/activity/"/>
    
    
      <category term="算法" scheme="http://McKinleyLu.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>最长公共子序列</title>
    <link href="http://mckinleylu.com/2019/10/30/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://mckinleylu.com/2019/10/30/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2019-10-30T07:19:23.000Z</published>
    <updated>2019-10-30T08:23:06.675Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定两个字符串，求其最大公共子序列</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>   本题是典型的动态规划问题，我们将大字符串分解成小字符串进行计算。<a id="more"></a>  </p><p>   为了节省空间，我们使用一维滚动数组求解</p><h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h3><ol><li><p>找到递推入口：当len(string_first) = 0 时, 一维数组元素均为零。</p><p>当len(string_second) = 0时,一维数组元素均为零</p></li><li><p>从字符串二长度为一开始，设置二层循环，对记录的一维数组进行修改</p></li><li><p>递归公式</p><p>若str1[i] == str2[j] , 则v[j] = tmp (tmp单独保存斜上角的数)</p><p>若str1[i] != str2[j] ,  则v[j] = max(v[j],v[j-1])</p></li><li><p>总时间复杂度 = O(len(str1) *len(str2))  约等于 O(n^2)</p></li></ol><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//文件操作</span></span><br><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">"Common_subsequence.txt"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!in)  &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"打开文件出错"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">return</span> <span class="number">0</span> ; &#125;</span><br><span class="line">    <span class="built_in">string</span> str1 , str2 ;</span><br><span class="line">    getline(in,str1);</span><br><span class="line">getline(in,str2);</span><br><span class="line"><span class="keyword">int</span> len1 = str1.size() , len2 = str2.size();</span><br><span class="line"><span class="keyword">int</span> arrays = max(len1,len2);</span><br><span class="line">str1 = <span class="string">'0'</span> + str1;</span><br><span class="line">str2 = <span class="string">'0'</span> + str2;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(arrays+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> row = arrays,col = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">string</span> stemp ;</span><br><span class="line"><span class="keyword">if</span>(len1 &gt;= len2) &#123;col = len2; stemp = str2 ; str2 = str1; str1 = stemp ;&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;col = len1 ;&#125;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span> , tmp = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= col ; ++i)&#123;</span><br><span class="line">            tmp = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= arrays ; ++j)&#123;</span><br><span class="line">    temp = v[j];</span><br><span class="line"><span class="keyword">if</span>(str1[i] == str2[j])&#123;v[j] = tmp + <span class="number">1</span>;&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;v[j] = max(v[j<span class="number">-1</span>],v[j]);&#125;</span><br><span class="line">tmp = temp ;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//输入每一行值</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= arrays ; ++i)&#123;<span class="built_in">cout</span> &lt;&lt; v[i] &lt;&lt; <span class="string">" "</span>;&#125;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//输入字符串一</span></span><br><span class="line">    str1 = str1.substr(<span class="number">1</span>,str1.size()<span class="number">-1</span>);</span><br><span class="line">    str2 = str2.substr(<span class="number">1</span>,str2.size()<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str1: "</span>&lt;&lt;str1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//输入字符串二</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str2: "</span>&lt;&lt;str2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="谢谢访问"><a href="#谢谢访问" class="headerlink" title="谢谢访问"></a>谢谢访问</h3><div style=" width:747px; height: 447px; margin:0 auto">   <img src="/images/thank.jpg" style=" margin:0 auto;  ">  </div>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;p&gt;给定两个字符串，求其最大公共子序列&lt;/p&gt;
&lt;h3 id=&quot;问题分析&quot;&gt;&lt;a href=&quot;#问题分析&quot; class=&quot;headerlink&quot; title=&quot;问题分析&quot;&gt;&lt;/a&gt;问题分析&lt;/h3&gt;&lt;p&gt;   本题是典型的动态规划问题，我们将大字符串分解成小字符串进行计算。
    
    </summary>
    
    
      <category term="算法课下实验" scheme="http://McKinleyLu.com/categories/%E7%AE%97%E6%B3%95%E8%AF%BE%E4%B8%8B%E5%AE%9E%E9%AA%8C/"/>
    
      <category term="Longest_common_subsequence" scheme="http://McKinleyLu.com/categories/%E7%AE%97%E6%B3%95%E8%AF%BE%E4%B8%8B%E5%AE%9E%E9%AA%8C/Longest-common-subsequence/"/>
    
    
      <category term="算法" scheme="http://McKinleyLu.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>苹果树剪枝</title>
    <link href="http://mckinleylu.com/2019/10/30/%E8%8B%B9%E6%9E%9C%E6%95%B0%E5%89%AA%E6%9E%9D/"/>
    <id>http://mckinleylu.com/2019/10/30/%E8%8B%B9%E6%9E%9C%E6%95%B0%E5%89%AA%E6%9E%9D/</id>
    <published>2019-10-30T07:12:13.000Z</published>
    <updated>2019-10-30T08:18:31.237Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>有一棵苹果树，如果树枝有分叉，一定是分2叉（就是说没有只有1个孩子的结点）。这棵树共有n个结点（叶子点或者树枝分叉点），编号为1~n，树根编号一定是1。<a id="more"></a>    </p><p>现在这棵树枝条太多了，需要剪枝。但是一些树枝上长有苹果。 给定需要保留的树枝数量P，求出最多能留住多少苹果。 </p><p>要求：</p><p>(1) 创建合适的数据结构存储树的信息。</p><p>(2) 设计问题的递归公式。</p><p>(3) 实现动态规划算法，输出保留的树枝数量P和最多留住的苹果数。</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>本题不仅涉及到动态规划的算法，还涉及到了数据结构-树。</p><p>首先，需要找一种树的存储方法，其次，为方便计算，将节点与树的枝条连在一起计算。</p><p>节点本身需要一个挂在树上的枝条，接下来是分类讨论它的左右孩子所有拥有的枝条数对应的最大苹果树。</p><p>使用一位数组存树，2<em>i即为其左子树，2</em>i+1即为其右子树</p><p>这类问题就是通过将大问题化解为同类小问题，找到递推入口(即从叶子节点)，并从入口向目标求解递推</p><h3 id="算法设计："><a href="#算法设计：" class="headerlink" title="算法设计："></a><strong>算法设计：</strong></h3><ol><li><p>储存树</p><p>由于题目给的是极其类似满二叉树的结构，故不使用递归的方法构造树，而采用一维数组，用少量空间换取大量时间。构造树的时间为线性时间n</p></li><li><p>初始化运算表</p><p>将每个节点所拥有一到p个枝条时最大苹果树用二位数组存放。C++构造二维数组所花线性时间为n</p><p>从子叶节点(递推入口开始)开始，对于子叶节点拥有一到p个枝条，苹果数值均为其本身苹果数。</p><p>枝条为零的情况下，所有节点所含苹果数为零</p></li><li><p>设计递推</p><p>递推方程式为 f[i][j] = max(f[i][j],f[i<em>2][k]+f[i</em>2+1][j-1-k]+ value[i]);</p><p>采用双重循环，求出每个节点从1到p枝条时的最大所含苹果数。所用时间n^p</p></li><li><p>得出结果</p><p>f[i] [p+1]即位整棵树最大苹果数。</p></li><li><p>总时间复杂度分析</p><p>T= t(初始化)+t(递推) = O(n^2) </p></li></ol><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">string_to_number</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(s)</span> </span>;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span> ;</span><br><span class="line">ss &gt;&gt; a ;</span><br><span class="line"><span class="keyword">return</span> a ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> number = <span class="number">0</span> , p = <span class="number">0</span> ;</span><br><span class="line"><span class="comment">//文件操作一</span></span><br><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">"apple.txt"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">string</span> line;</span><br><span class="line">    <span class="keyword">if</span>(!in)  &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"打开文件出错"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">return</span> <span class="number">0</span> ; &#125;</span><br><span class="line">getline(in,line);</span><br><span class="line">number = string_to_number(line);</span><br><span class="line">line.clear();</span><br><span class="line">getline(in,line);</span><br><span class="line">p = string_to_number(line);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; value(number+<span class="number">1</span>);</span><br><span class="line"><span class="comment">//文件操作二</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; number+<span class="number">1</span> ; ++i)&#123; line.clear() ; getline(in,line); value[i] = string_to_number(line);&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; f(number+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; number + <span class="number">1</span> ; ++i)&#123;f[i].resize(p+<span class="number">2</span>);&#125;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; number + <span class="number">1</span> ; ++i)&#123;f[i][<span class="number">0</span>] = <span class="number">0</span> ; f[i][<span class="number">1</span>] = value[i];&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = number  ; i &gt;= <span class="number">1</span>; --i )&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span> ; j &lt;= p + <span class="number">1</span> ; ++j)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; j ; ++k)&#123;</span><br><span class="line"> <span class="keyword">if</span>(i*<span class="number">2</span> &lt;= number)&#123;f[i][j] = max(f[i][j],f[i*<span class="number">2</span>][k]+f[i*<span class="number">2</span>+<span class="number">1</span>][j<span class="number">-1</span>-k]+ value[i]);&#125;</span><br><span class="line">    <span class="comment">//没有左子树以及右子树，则该值为其本身价值</span></span><br><span class="line"><span class="keyword">else</span>&#123;f[i][j] = value[i] ;&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f[<span class="number">1</span>][p+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="谢谢访问"><a href="#谢谢访问" class="headerlink" title="谢谢访问"></a>谢谢访问</h3><div style=" width:747px; height: 447px; margin:0 auto">   <img src="/images/thank.jpg" style=" margin:0 auto;  ">  </div>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;p&gt;有一棵苹果树，如果树枝有分叉，一定是分2叉（就是说没有只有1个孩子的结点）。这棵树共有n个结点（叶子点或者树枝分叉点），编号为1~n，树根编号一定是1。
    
    </summary>
    
    
      <category term="算法课下实验" scheme="http://McKinleyLu.com/categories/%E7%AE%97%E6%B3%95%E8%AF%BE%E4%B8%8B%E5%AE%9E%E9%AA%8C/"/>
    
      <category term="Apple_tree_pruning" scheme="http://McKinleyLu.com/categories/%E7%AE%97%E6%B3%95%E8%AF%BE%E4%B8%8B%E5%AE%9E%E9%AA%8C/Apple-tree-pruning/"/>
    
    
      <category term="算法" scheme="http://McKinleyLu.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>背包一维数组实现</title>
    <link href="http://mckinleylu.com/2019/10/30/%E8%83%8C%E5%8C%85%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://mckinleylu.com/2019/10/30/%E8%83%8C%E5%8C%85%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2019-10-30T07:01:21.000Z</published>
    <updated>2019-10-30T08:11:29.188Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="背包分类"><a href="#背包分类" class="headerlink" title="背包分类"></a>背包分类</h3><h4 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h4><p>只用考虑物品放与不放<a id="more"></a>  </p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; volume(c) ;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++i)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = c ; j &gt;=weight[i] ; j--)&#123;</span><br><span class="line">    volume[j] = max(volume[j] , volume[j-weight[i]] + value[i]);</span><br></pre></td></tr></table></figure><h4 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h4><p>每种物品数量不限</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++i)&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> j = weight[i] ; j &lt;= n ; ++j)&#123;</span><br><span class="line">   f[j] = max(volume[j] , volume[j-weight[i]] + value[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="限制背包"><a href="#限制背包" class="headerlink" title="限制背包"></a>限制背包</h4><p>每种物品数量可能不止一个</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=c[i];k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j-k*a[i]&lt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        f[j]=max(f[j],f[j-k*a[i]]+k*b[i]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>详细分析请看</p><p>算法实验之限制背包</p><h3 id="谢谢访问"><a href="#谢谢访问" class="headerlink" title="谢谢访问"></a>谢谢访问</h3><div style=" width:747px; height: 447px; margin:0 auto">   <img src="/images/thank.jpg" style=" margin:0 auto;  ">  </div>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背包分类&quot;&gt;&lt;a href=&quot;#背包分类&quot; class=&quot;headerlink&quot; title=&quot;背包分类&quot;&gt;&lt;/a&gt;背包分类&lt;/h3&gt;&lt;h4 id=&quot;0-1背包&quot;&gt;&lt;a href=&quot;#0-1背包&quot; class=&quot;headerlink&quot; title=&quot;0-1背包&quot;&gt;&lt;/a&gt;0-1背包&lt;/h4&gt;&lt;p&gt;只用考虑物品放与不放
    
    </summary>
    
    
      <category term="算法课下实验" scheme="http://McKinleyLu.com/categories/%E7%AE%97%E6%B3%95%E8%AF%BE%E4%B8%8B%E5%AE%9E%E9%AA%8C/"/>
    
      <category term="Pacage_problem_One-dimensiona" scheme="http://McKinleyLu.com/categories/%E7%AE%97%E6%B3%95%E8%AF%BE%E4%B8%8B%E5%AE%9E%E9%AA%8C/Pacage-problem-One-dimensiona/"/>
    
    
      <category term="算法" scheme="http://McKinleyLu.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>背包问题</title>
    <link href="http://mckinleylu.com/2019/10/30/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>http://mckinleylu.com/2019/10/30/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</id>
    <published>2019-10-30T06:45:00.000Z</published>
    <updated>2019-10-30T07:53:14.580Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>已知n种物品的体积、价值和数量，背包的容积为C，从物品中选择装入背包的物品，每种物品装入数量不超过物品的数量，请设计算法求出装入价值最大的装法。<a id="more"></a>  </p><p>要求：</p><p>(1) 输入n种物品的体积、价值和数量，输入背包的容积。</p><p>(2) 分析给出带限制的整数背包问题的递归公式。</p><p>(3) 利用动态规划算法编程求解，输出每种物品装入背包的个数和装入背包的最大价值。</p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><h4 id="问题分析："><a href="#问题分析：" class="headerlink" title="问题分析："></a><strong>问题分析：</strong></h4><p>这是一个有限制物品数量的背包，一个典型的动态规划问题。在这里，我们不仅要使用二维数组解出背包最大价值，还要直到放了哪个物品多少件</p><h4 id="算法设计："><a href="#算法设计：" class="headerlink" title="算法设计："></a><strong>算法设计：</strong></h4><p> 采用动态规划的方法解出此题：</p><ol><li><p>部分最优则整体最优。</p><p>从背包只放入一种物品开始，每次背包容量加一，并在该容量判断背包在实现最大价值的情况下，最多可以加入该物品多少个。显然符合动态规划部分最优全局最优规则</p></li><li><p>动规递推入口</p><p>即当背包内物品种类为零时，任意容量价值均为零</p><p>当背包容量为零时，物品种类所对应价值均为零</p><p>从背包有一种物品，背包容积为最大容积开始递推。</p></li><li><p>动规方程式</p><p>v[i][j] = max(v[i][j] , v[i][j – weight[i]<em>k] + value[i]</em>k);</p></li><li><p>复杂度分析：</p><ul><li><p>定义数组以及价值初始化</p><p>首先，定义结构体，包含物品价格以及每种物品放入价格。由于使用C++的vector结构，故省去C语言初始化线性时间n;</p></li><li><p>对存放物品个数计数的数组进行初始化，需花费n^m时间</p></li><li>使用三重循环，按照背包内装有几种物品、对应背包容量、放几个对应物品，对表进行递推运算，此时时间复杂度为n^3</li><li>总结：时间复杂度为O(n^3),但要比三维数组的时间复杂度以及空间复杂度小</li></ul></li></ol><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">      <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">     <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers ;</span><br><span class="line">&#125;pacage;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">string_to_number</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(s)</span> </span>;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span> ;</span><br><span class="line">ss &gt;&gt; a ;</span><br><span class="line"><span class="keyword">return</span> a ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">"package.txt"</span>)</span></span>;</span><br><span class="line">   <span class="keyword">int</span> m = <span class="number">0</span> , n = <span class="number">0</span> ;        <span class="comment">// 背包容积、物品种类</span></span><br><span class="line">   <span class="built_in">string</span> s ;</span><br><span class="line">   getline(in,s);</span><br><span class="line">   m = string_to_number(s);</span><br><span class="line">   s.clear();</span><br><span class="line">   getline(in,s);</span><br><span class="line">   n = string_to_number(s);</span><br><span class="line"><span class="comment">//------------------------------------------------------</span></span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; value(n+<span class="number">1</span>);    <span class="comment">// 每种物品的价值</span></span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; weight(n+<span class="number">1</span>);   <span class="comment">// 每种物品一个重量</span></span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; number(n+<span class="number">1</span>);   <span class="comment">// 每种物品数量</span></span><br><span class="line">   <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;pacage&gt; &gt; v(n+<span class="number">1</span>) ;    <span class="comment">// 物品总价值</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; ++i)&#123;v[i].resize(m+<span class="number">1</span>);&#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++i) &#123;s.clear();getline(in,s); value[i] = string_to_number(s);  &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++i) &#123;s.clear();getline(in,s); weight[i] = string_to_number(s); &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++i) &#123;s.clear();getline(in,s); number[i] = string_to_number(s); &#125;</span><br><span class="line"><span class="comment">//------------------------------------------------------</span></span><br><span class="line">  <span class="comment">//限制背包</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m ; ++j) &#123;  v[i][j].numbers.resize(<span class="number">100</span>);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = m ; j &gt;= <span class="number">0</span> ;--j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt;= number[i] ; ++k)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &lt; k*weight[i]) &#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">                <span class="keyword">if</span>( v[i][j].value &lt; v[i<span class="number">-1</span>][j-weight[i]*k].value + value[i]*k)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">0</span> ; s &lt; <span class="number">100</span> ; ++s)  &#123; v[i][j].numbers[s] = v[i<span class="number">-1</span>][j-weight[i]*k].numbers[s]; &#125;</span><br><span class="line">                    v[i][j].value = v[i<span class="number">-1</span>][j-weight[i]*k].value + value[i]*k;</span><br><span class="line">                    v[i][j].numbers[i] = k ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"背包最优的价值情况"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"物品编号 物品数量 物品价值 单个物品体积"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++i)&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"   "</span>&lt;&lt;i&lt;&lt;<span class="string">"          "</span>&lt;&lt;v[n][m].numbers[i] &lt;&lt;<span class="string">"      "</span>&lt;&lt;value[i] &lt;&lt; <span class="string">"       "</span>&lt;&lt;weight[i]&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"背包内物品最高价值"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; v[n][m].value;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="谢谢访问"><a href="#谢谢访问" class="headerlink" title="谢谢访问"></a>谢谢访问</h3><div style=" width:747px; height: 447px; margin:0 auto">   <img src="/images/thank.jpg" style=" margin:0 auto;  ">  </div>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;p&gt;已知n种物品的体积、价值和数量，背包的容积为C，从物品中选择装入背包的物品，每种物品装入数量不超过物品的数量，请设计算法求出装入价值最大的装法。
    
    </summary>
    
    
      <category term="算法课下实验" scheme="http://McKinleyLu.com/categories/%E7%AE%97%E6%B3%95%E8%AF%BE%E4%B8%8B%E5%AE%9E%E9%AA%8C/"/>
    
      <category term="Pacage_problem" scheme="http://McKinleyLu.com/categories/%E7%AE%97%E6%B3%95%E8%AF%BE%E4%B8%8B%E5%AE%9E%E9%AA%8C/Pacage-problem/"/>
    
    
      <category term="算法" scheme="http://McKinleyLu.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>寻找中项和第k小元素</title>
    <link href="http://mckinleylu.com/2019/10/16/%E5%AF%BB%E6%89%BE%E4%B8%AD%E9%A1%B9%E5%92%8C%E7%AC%ACk%E5%B0%8F%E5%85%83%E7%B4%A0%E3%80%81/"/>
    <id>http://mckinleylu.com/2019/10/16/%E5%AF%BB%E6%89%BE%E4%B8%AD%E9%A1%B9%E5%92%8C%E7%AC%ACk%E5%B0%8F%E5%85%83%E7%B4%A0%E3%80%81/</id>
    <published>2019-10-16T08:08:42.000Z</published>
    <updated>2019-11-10T08:13:03.561Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>在统计学领域中，中项是一个非常关键的常用的指标值。序列的中项是指排好序后序列的“中间”元素，中项是指序列的第[n/2]个最小元素。寻找序列中项的问题被称为中项值问题，寻找序列中第k小元素的问题被称为选择问题。<a id="more"></a>  </p><p>要求：</p><ol><li><p>元素个数n≥100。</p></li><li><p>请利用减治的思想，设计该问题的分治算法。</p></li><li>采用两种划分的方式：教材上的方法和随机选择的方法，并对比两种方法的性能</li></ol><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>在平常寻找向量(数组、容器)数值第k个元素时，我们一般使用快速排序将元素按指定规则排序，则第k个元素位置即排好序的第k-1向量位置。这种方法平均时间复杂度为O(nlogn – n +1)。</p><p>这里，我们采用分治方法，降低时间复杂度为线性。</p><h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h3><ol><li><p>先将数组按照每五个分为一组，剩下多余元素排去</p></li><li><p>其次将分好的数组用快排排序，时间为cn(c约等于7)，所以时间消耗为线性阶</p></li><li><p>去各分组数组的中值构成一个新数组，并求出新数组中值mm。时间消耗为线性阶</p></li><li><p>根据中值mm，将中值mm设置为基准，原数组根据mm划成三个集合A，B，C。(A中元素值小于mm,B中元素值等于mm，C中元素值大于mm)</p></li><li><p>根据如下情况进行下一步</p><p>如果A集合数字个数大于K，则返回select(A,0,high,k)</p><p>如果A + B 集合的数字个数等于K，则mm即位所求，返回mm即可</p><p>否则 select(C,0,high,k)</p></li><li><p>分治过程如下</p><ul><li>分：将数组分按照mm为三个集合</li><li>治：判断k在哪个集合，不同集合治法不同</li><li>组合： 这里涉及到了简治，即排除不可能为所寻找元素，降低了时间复杂度</li><li>阈值：当集合值为mm时，返回mm。</li></ul></li></ol><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left &lt; right)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i = left, j = right, k = a[left];</span><br><span class="line"> <span class="comment">//利用循环，使基准左边数字均小于基准，右边均大于基准</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; a[j] &lt; k) &#123; --j; &#125;  <span class="comment">//从右向左找到第一个比基准大的数</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; j) &#123; a[i++] = a[j]; &#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; a[i] &gt; k) &#123; ++i; &#125;  <span class="comment">//从左向右找到第一个比基准小的数</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; j) &#123; a[j--] = a[i]; &#125;</span><br><span class="line"> &#125;</span><br><span class="line">a[i] = k;</span><br><span class="line">QuickSort(a, left, i - <span class="number">1</span>);     <span class="comment">// 排序k左边</span></span><br><span class="line">    QuickSort(a, i + <span class="number">1</span>, right);    <span class="comment">// 排序k右边</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;a,<span class="keyword">int</span> &amp;numa, <span class="keyword">int</span> &amp; numb ,<span class="keyword">const</span> <span class="keyword">int</span> mm)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">0</span> , j = a.size()<span class="number">-1</span> , k = mm;</span><br><span class="line">     <span class="comment">//利用循环，使基准左边数字均小于基准，右边均大于基准</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; a[j] &lt; k) &#123; --j; &#125;  <span class="comment">//从右向左找到第一个比基准大的数</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; j) &#123; a[i++] = a[j]; &#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; a[i] &gt; k) &#123; ++i; &#125;  <span class="comment">//从左向右找到第一个比基准小的数</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; j) &#123; a[j--] = a[i]; &#125;</span><br><span class="line"> &#125;</span><br><span class="line">a[i] = mm;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; a.size()<span class="number">-1</span> ;++i)&#123;<span class="keyword">if</span>(a[i] == mm)&#123;numb++;&#125;&#125;</span><br><span class="line">numa = i + <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_K_Element</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;v,<span class="keyword">int</span> low,<span class="keyword">int</span> high,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = high - low + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(p &lt; <span class="number">44</span>) &#123;</span><br><span class="line">      QuickSort(v,low,high);</span><br><span class="line">      <span class="keyword">return</span> v[v.size() / <span class="number">2</span>];</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; m ;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">2</span> , mm = <span class="number">0</span>,pos = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//分组并排序</span></span><br><span class="line">    <span class="keyword">int</span> cnt = (high - low + <span class="number">1</span>)/ <span class="number">5</span> ;</span><br><span class="line">    <span class="keyword">int</span> left = low ,right = low + <span class="number">4</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; cnt ; ++i)&#123;</span><br><span class="line">        QuickSort(v,left,right);</span><br><span class="line">        left  += <span class="number">5</span> ;</span><br><span class="line">        right += <span class="number">5</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分组中项排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; cnt ; ++i)&#123;</span><br><span class="line">        m.push_back(v[tmp]);</span><br><span class="line">        tmp += <span class="number">5</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    QuickSort(m,<span class="number">0</span>,m.size()<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(m.size() % <span class="number">2</span> == <span class="number">0</span>)&#123;mm = m[m.size() / <span class="number">2</span> - <span class="number">1</span>];&#125;</span><br><span class="line">    <span class="keyword">else</span>                 &#123;mm = m[(m.size()+<span class="number">1</span>) / <span class="number">2</span> - <span class="number">1</span>];&#125;</span><br><span class="line">    <span class="comment">//确定mm在原数组的位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; v.size()<span class="number">-1</span> ; ++i)&#123;<span class="keyword">if</span>(v[i] == mm)&#123;pos = i ; <span class="keyword">break</span>;&#125;&#125;</span><br><span class="line">    <span class="comment">//分A,B,C三个数组</span></span><br><span class="line">    <span class="keyword">int</span> numa = <span class="number">0</span> , numb = <span class="number">0</span> , numc = <span class="number">0</span>;</span><br><span class="line">    divide(v,numa,numb,mm);</span><br><span class="line">    numc = v.size() - numa - numb ;</span><br><span class="line">         <span class="comment">//cout&lt;&lt;mm&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">if</span>(numa &gt; k )&#123;</span><br><span class="line">        Search_K_Element(v,low,numa - <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(numa + numb &gt;= v.size() / <span class="number">2</span> ) &#123;<span class="keyword">return</span> mm ;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Search_K_Element(v,numa + numb,numc - <span class="number">1</span>, k - numa - numb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v ;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入待寻找中项数组,以r字母结束"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">int</span> r =<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;tmp);</span><br><span class="line">        <span class="keyword">if</span>(r == <span class="number">0</span>)&#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; v.push_back(tmp);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">int</span> k ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; k ;</span><br><span class="line">    <span class="keyword">int</span> result = Search_K_Element(v,<span class="number">0</span>,v.size()<span class="number">-1</span>,k);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;result&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt; v.size() ; ++i) &#123;<span class="built_in">cout</span> &lt;&lt; v[i] &lt;&lt; <span class="string">" "</span>;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="谢谢访问"><a href="#谢谢访问" class="headerlink" title="谢谢访问"></a>谢谢访问</h3><div style=" width:747px; height: 447px; margin:0 auto">   <img src="/images/thank.jpg" style=" margin:0 auto;  ">  </div>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;p&gt;在统计学领域中，中项是一个非常关键的常用的指标值。序列的中项是指排好序后序列的“中间”元素，中项是指序列的第[n/2]个最小元素。寻找序列中项的问题被称为中项值问题，寻找序列中第k小元素的问题被称为选择问题。
    
    </summary>
    
    
      <category term="算法课下实验" scheme="http://McKinleyLu.com/categories/%E7%AE%97%E6%B3%95%E8%AF%BE%E4%B8%8B%E5%AE%9E%E9%AA%8C/"/>
    
      <category term="Search-K-Element" scheme="http://McKinleyLu.com/categories/%E7%AE%97%E6%B3%95%E8%AF%BE%E4%B8%8B%E5%AE%9E%E9%AA%8C/Search-K-Element/"/>
    
    
      <category term="算法" scheme="http://McKinleyLu.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>大整数乘法</title>
    <link href="http://mckinleylu.com/2019/10/16/%E5%A4%A7%E6%95%B4%E6%95%B0%E4%B9%98%E6%B3%95/"/>
    <id>http://mckinleylu.com/2019/10/16/%E5%A4%A7%E6%95%B4%E6%95%B0%E4%B9%98%E6%B3%95/</id>
    <published>2019-10-16T07:51:31.000Z</published>
    <updated>2019-10-20T05:57:44.491Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>程序设计语言中的整型数据类型可以存放一定范围内的整数，超出这个范围的大整数就不能再用普通变量存储和操作，这样的整数通常被称为“大整数”。大整数的存储需要借助于数组或链表等，其操作也需要编写程序完成。<a id="more"></a></p><p>要求：</p><ol><li><p>大整数的位数n≥16，可以是十进制或者二进制数。</p></li><li><p>两个大整数相乘如果按照传统的方法，需要耗费n2次数量相乘，试设计大整数乘法的分治算法，要求时间复杂度低于n2阶。</p></li></ol><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><ol><li><p>我们采用分治算法，具体算法如下</p><p>我们将n位的二进制整数X和Y各分为2段，每段的长为n/2位（为简单起见，假设n是2的幂），有下图形式</p><p><img src="/images/3-1.jpg" style=" margin:0 auto;  "></p></li><li><p>计算公式为  </p><p> XY = (A2^(n/2)+B)(C2^(n/2)+D)=AC2^n+(AD+CB)2^(n/2)+BD  </p><p>对于2的n次方，我们采用左移n位即可，需要的时间为n。另外需要四次乘法以及三次加法，这蕴含下图递推式：</p><p><img src="/images/3-2.jpg" style=" margin:0 auto;  "></p></li><li><p>​      由数学方法我们可知该算法时间复杂度为n^2    </p><p>​     所以采用Toom—Cook算法对上面的算法进行优化：  </p><p>​     wz + xy = (w + x )(y + z) -wy – xz  </p><p>​     再结合上面的算式，我们仅计算三次乘法以及次加减 运算，此中方法的递推式如下  </p><p><img src="/images/3-3.jpg" style=" margin:0 auto;  "></p></li><li><p>经计算，使用Toom—Cook算法的时间复杂度为O(n^1.59)。</p><p>分治过程如下：</p><ul><li><p>分: 将两个大整数分别分成四个较小整数</p></li><li><p>治：利用Toom—Cook算法进行计算</p></li><li><p>组合:  将每次算出的结果以字符串拼接相加</p></li><li><p>阈值： 这里设置阈值为4，不再分，并将运算结果返回</p></li><li><p>直接运算 ： 当数字的位数为4时，直接计算两数乘法。</p></li></ul></li></ol><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="comment">//函数功能：分治法求两个N为的整数的乘积</span></span><br><span class="line"><span class="comment">//输入参数：X,Y分别为两个N为整数</span></span><br><span class="line"><span class="comment">//h核心优化方程 ：uv  =   wy2n+[(w-x)(z-y)+wy+xz]2n/2+xz</span></span><br><span class="line"><span class="comment">//时间复杂度为：T(n)=O(nlog3)=O(n1.59)</span></span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//C++数字转字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">number_to_string</span><span class="params">(<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="built_in">stringstream</span> ss ;</span><br><span class="line">ss &lt;&lt; m ;</span><br><span class="line"><span class="built_in">string</span> re ;</span><br><span class="line">ss &gt;&gt; re ;</span><br><span class="line"><span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//C++字符串转数字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">string_to_number</span><span class="params">(<span class="built_in">string</span> m)</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(m)</span></span>;</span><br><span class="line">  <span class="keyword">int</span> s ;</span><br><span class="line">  ss &gt;&gt; s ;</span><br><span class="line">  <span class="keyword">return</span> s ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在数字前面加0</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">same_number_zero_before</span><span class="params">(<span class="built_in">string</span> m , <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s  ; ++i)&#123;m.insert(<span class="number">0</span>,<span class="string">"0"</span>);&#125;</span><br><span class="line"><span class="keyword">return</span> m ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在数字后面加零</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">same_number_zero_follow</span><span class="params">(<span class="built_in">string</span> m , <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s ; ++i) &#123;m.insert(m.size(),<span class="string">"0"</span>);&#125;</span><br><span class="line"><span class="keyword">return</span> m ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两个数字相加</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">string_add</span><span class="params">(<span class="built_in">string</span> a , <span class="built_in">string</span> b)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(a.size() &gt; b.size())      &#123;b = same_number_zero_before(b,a.size() - b.size()) ;&#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(b.size() &gt; a.size()) &#123;a = same_number_zero_before(a,b.size() - a.size()) ;&#125;</span><br><span class="line">   <span class="built_in">string</span> result;</span><br><span class="line">   <span class="keyword">int</span> co = <span class="number">0</span> ;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = a.size() - <span class="number">1</span> ; i &gt;= <span class="number">0</span> ; --i)&#123;</span><br><span class="line">      <span class="keyword">int</span> c = (a[i] - <span class="string">'0'</span>) + (b[i] - <span class="string">'0'</span>) + co;</span><br><span class="line">      co =  c / <span class="number">10</span> ;</span><br><span class="line">      c  %= <span class="number">10</span> ;</span><br><span class="line">      result.insert(<span class="number">0</span>,number_to_string(c));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(co != <span class="number">0</span>)&#123;result.insert(<span class="number">0</span>,number_to_string(co));&#125;</span><br><span class="line">   <span class="keyword">return</span> result ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">string_sub</span><span class="params">(<span class="built_in">string</span> a , <span class="built_in">string</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(a[<span class="number">0</span>] == <span class="string">'0'</span> &amp;&amp; a.size() &gt; <span class="number">1</span>) &#123;a = a.substr(<span class="number">1</span>,a.size()<span class="number">-1</span>);&#125;</span><br><span class="line"><span class="keyword">while</span>(b[<span class="number">0</span>] == <span class="string">'0'</span> &amp;&amp; b.size() &gt; <span class="number">1</span>) &#123;b = b.substr(<span class="number">1</span>,b.size()<span class="number">-1</span>);&#125;</span><br><span class="line"><span class="keyword">if</span>(a.size() &gt; b.size())&#123; b = same_number_zero_before(b,a.size() - b.size());&#125;</span><br><span class="line"><span class="built_in">string</span> result ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.size() - <span class="number">1</span> ; i &gt;= <span class="number">0</span> ; --i)&#123;</span><br><span class="line">    <span class="keyword">int</span> c = (a[i] - <span class="string">'0'</span>) - (b[i] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">if</span>(c &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    c += <span class="number">10</span> ;</span><br><span class="line">    <span class="keyword">int</span> prepos = i <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">char</span> prechar = a[prepos];</span><br><span class="line">    <span class="keyword">while</span>(prechar == <span class="string">'0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    a[prepos] = <span class="string">'9'</span>;</span><br><span class="line">    prepos = <span class="number">-1</span> ;</span><br><span class="line">    prechar = a[prepos];</span><br><span class="line">    &#125;</span><br><span class="line">    a[prepos] -= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">         result.insert(<span class="number">0</span>,number_to_string(c));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算string数字的乘法函数</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">multi</span><span class="params">(<span class="built_in">string</span> u , <span class="built_in">string</span> v)</span></span>&#123;</span><br><span class="line"><span class="comment">//首先将两个数前面的0去除,保留有效的计算位数</span></span><br><span class="line"><span class="keyword">while</span>(u[<span class="number">0</span>] == <span class="string">'0'</span> &amp;&amp; u.size() &gt; <span class="number">1</span>)&#123;u = u.substr(<span class="number">1</span>,u.size()<span class="number">-1</span>);&#125;</span><br><span class="line"><span class="keyword">while</span>(v[<span class="number">0</span>] == <span class="string">'0'</span> &amp;&amp; v.size() &gt; <span class="number">1</span>)&#123;v = v.substr(<span class="number">1</span>,v.size()<span class="number">-1</span>);&#125;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">4</span> ;</span><br><span class="line"><span class="keyword">if</span>(u.size() &gt; <span class="number">2</span> || v.size() &gt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(u.size() &gt;=  v.size())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//f为2的n次方位数大小，直到f的位数与x或者y中的 最大的 一个数 位数 相同或者大 停止</span></span><br><span class="line"><span class="keyword">while</span>(u.size() &gt; n)&#123; n *= <span class="number">2</span> ;&#125;</span><br><span class="line"><span class="keyword">if</span>(u.size() != n)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//为了计算两个数，使u,v,f三个数位数相同</span></span><br><span class="line">   u = same_number_zero_before(u,n-u.size());</span><br><span class="line">   v = same_number_zero_before(v,n-v.size());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">          <span class="comment">//f为2的n次方大小，直到f的位数比x或者y中的最大的一个数位数大停止</span></span><br><span class="line"><span class="keyword">while</span>(v.size() &gt; n)&#123; n *= <span class="number">2</span> ;&#125;</span><br><span class="line"><span class="keyword">if</span>(v.size() != n)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//为了计算两个数，使u,v,f三个数位数相同</span></span><br><span class="line">   u = same_number_zero_before(u,n-u.size());</span><br><span class="line">   v = same_number_zero_before(v,n-v.size());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//时刻保证u以及v有两位</span></span><br><span class="line"><span class="keyword">if</span>(u.size() == <span class="number">1</span> )&#123;u = same_number_zero_before(u,<span class="number">1</span>);&#125;</span><br><span class="line"><span class="keyword">if</span>(v.size() == <span class="number">1</span> )&#123;v = same_number_zero_before(v,<span class="number">1</span>);&#125;</span><br><span class="line"><span class="comment">//时刻保证u、v位数相同</span></span><br><span class="line"><span class="keyword">if</span>(u.size() &gt; v.size())&#123;v = same_number_zero_before(v,u.size() - v.size());&#125;</span><br><span class="line"><span class="keyword">if</span>(u.size() &lt; v.size())&#123;u = same_number_zero_before(u,v.size() - u.size());&#125;</span><br><span class="line"><span class="comment">//确定两数的位数</span></span><br><span class="line"><span class="keyword">int</span> num = u.size();</span><br><span class="line"><span class="comment">//分割u,v</span></span><br><span class="line"><span class="built_in">string</span> w , x , y , z ;</span><br><span class="line"><span class="keyword">if</span>(num &gt; <span class="number">1</span>)&#123;</span><br><span class="line">w = u.substr(<span class="number">0</span>, num / <span class="number">2</span> );</span><br><span class="line">x = u.substr(num/<span class="number">2</span> , num - <span class="number">1</span>);</span><br><span class="line">y = v.substr(<span class="number">0</span>, num / <span class="number">2</span>);</span><br><span class="line">z = v.substr(num / <span class="number">2</span> , num - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> result ;</span><br><span class="line"><span class="comment">//循环阈值为2，结束递归，回迭</span></span><br><span class="line"><span class="keyword">if</span>(num == <span class="number">2</span> )&#123;</span><br><span class="line"><span class="keyword">int</span> nw = string_to_number(w);</span><br><span class="line"><span class="keyword">int</span> nx = string_to_number(x);</span><br><span class="line"><span class="keyword">int</span> ny = string_to_number(y);</span><br><span class="line"><span class="keyword">int</span> nz = string_to_number(z);</span><br><span class="line">result = number_to_string((nw*<span class="number">10</span> + nx)*(ny*<span class="number">10</span> +nz));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span> c1 =  multi(w,y);</span><br><span class="line"><span class="built_in">string</span> c2 =  multi(x,z);</span><br><span class="line"><span class="built_in">string</span> c11 = string_add(w,x);</span><br><span class="line"><span class="built_in">string</span> c22 = string_add(y,z);</span><br><span class="line"><span class="built_in">string</span> c33 = multi(c11,c22);</span><br><span class="line"><span class="built_in">string</span> c44 = string_add(c1,c2);</span><br><span class="line"><span class="built_in">string</span> c55 = string_sub(c33,c44);</span><br><span class="line"><span class="built_in">string</span> ss1 = same_number_zero_follow(c55,num/ <span class="number">2</span>);</span><br><span class="line"><span class="built_in">string</span> ss2 = same_number_zero_follow(c1 , num );</span><br><span class="line">result = string_add(string_add(ss2,ss1),c2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span> ;</span><br><span class="line"><span class="comment">//循环计算多组大数乘法</span></span><br><span class="line"><span class="keyword">while</span>(flag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span> u , v ;</span><br><span class="line"><span class="keyword">int</span> sign = <span class="number">0</span> ,sign1 = <span class="number">0</span>, sign2 = <span class="number">0</span> ;</span><br><span class="line"><span class="comment">//程序使用提示</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"大整数 - 分治法 - C++版 - O(n^1.53)"</span> &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line"><span class="comment">//输入第一个数</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入第一个数"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">bool</span> inputfunction = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(inputfunction)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;u;</span><br><span class="line">  <span class="keyword">int</span> f = <span class="number">0</span> ;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; u.size() ; ++i)</span><br><span class="line">  &#123;</span><br><span class="line"><span class="keyword">if</span>(u[i] &lt; <span class="string">'0'</span> || u[i] &gt; <span class="string">'9'</span>)&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"输入数据非法，请重新输入"</span>&lt;&lt;<span class="built_in">endl</span>;f = <span class="number">1</span> ;<span class="keyword">break</span>;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(f == <span class="number">0</span>)&#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//输入第二个数</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入第二个数"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">while</span>(inputfunction)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; v;</span><br><span class="line">  <span class="keyword">int</span> f = <span class="number">0</span> ;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; v.size() ; ++i)</span><br><span class="line">  &#123;</span><br><span class="line"><span class="keyword">if</span>(v[i] &lt; <span class="string">'0'</span> || v[i] &gt; <span class="string">'9'</span>)&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"输入数据非法，请重新输入"</span>&lt;&lt;<span class="built_in">endl</span>; f = <span class="number">1</span> ;<span class="keyword">break</span>;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(f == <span class="number">0</span>)&#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//取出各个数字的符号位</span></span><br><span class="line"><span class="keyword">if</span>(u[<span class="number">0</span>] != <span class="string">'-'</span>)&#123;sign1 = <span class="number">1</span> ;&#125; <span class="keyword">else</span>&#123;sign1 = <span class="number">-1</span>;u = u.substr(<span class="number">1</span>,u.size()<span class="number">-1</span>);&#125;</span><br><span class="line"><span class="keyword">if</span>(v[<span class="number">0</span>] != <span class="string">'-'</span>)&#123;sign2 = <span class="number">1</span> ;&#125; <span class="keyword">else</span>&#123;sign2 = <span class="number">-1</span>;v = v.substr(<span class="number">1</span>,v.size()<span class="number">-1</span>);&#125;</span><br><span class="line"><span class="comment">//求出两数相乘符号位</span></span><br><span class="line">sign = sign1 * sign2 ;</span><br><span class="line"><span class="comment">//计算两个数的abs乘积值,并以string输出</span></span><br><span class="line"><span class="built_in">string</span> result = multi(u,v);</span><br><span class="line">    <span class="keyword">while</span>(<span class="string">'0'</span> == result[<span class="number">0</span>] &amp;&amp; result.size() &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result = result.substr(<span class="number">1</span>,result.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"结果："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(sign == <span class="number">-1</span>) &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">'-'</span>;&#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"继续请输入1，否则输入任意字符"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">string</span> s ;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s ;</span><br><span class="line">        <span class="keyword">if</span>(s.size() == <span class="number">1</span> &amp;&amp; s[<span class="number">0</span>] == <span class="string">'1'</span>) &#123;<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="谢谢访问"><a href="#谢谢访问" class="headerlink" title="谢谢访问"></a>谢谢访问</h3><div style=" width:747px; height: 447px; margin:0 auto">   <img src="/images/thank.jpg" style=" margin:0 auto;  ">  </div>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;程序设计语言中的整型数据类型可以存放一定范围内的整数，超出这个范围的大整数就不能再用普通变量存储和操作，这样的整数通常被称为“大整数”。大整数的存储需要借助于数组或链表等，其操作也需要编写程序完成。
    
    </summary>
    
    
      <category term="算法课下实验" scheme="http://McKinleyLu.com/categories/%E7%AE%97%E6%B3%95%E8%AF%BE%E4%B8%8B%E5%AE%9E%E9%AA%8C/"/>
    
      <category term="Big-number-Multiple" scheme="http://McKinleyLu.com/categories/%E7%AE%97%E6%B3%95%E8%AF%BE%E4%B8%8B%E5%AE%9E%E9%AA%8C/Big-number-Multiple/"/>
    
    
      <category term="算法" scheme="http://McKinleyLu.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>冒泡排序</title>
    <link href="http://mckinleylu.com/2019/09/15/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>http://mckinleylu.com/2019/09/15/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</id>
    <published>2019-09-15T08:44:33.000Z</published>
    <updated>2019-09-15T10:07:06.439Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p><code>冒泡排序</code>是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 <a id="more"></a> </p><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><ul><li><p>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</p></li><li><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</p></li><li><p>针对所有的元素重复以上的步骤，除了最后一个；</p></li><li><p>重复步骤1~3，直到排序完成。</p></li></ul><h4 id="算法图解"><a href="#算法图解" class="headerlink" title="算法图解"></a>算法图解</h4><div style=" width:747px; height: 447px; margin:0 auto">   <img src="/images/2.gif" style=" margin:0 auto;  ">  </div><h4 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h4><p>最好情况：数组已满足要求排序顺序，此时只需要n-1比较</p><p>最坏情况：数组与要求排序顺序刚好相反。此时比较次数 1/2<em>(n^2 - n)次，需要赋值次数3/2</em>(n^2-n)次 </p><p>综合，时间复杂度为O(n^2)</p><h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bubble_Sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N - i; ++j) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (a[j + <span class="number">1</span>] &lt; a[j]) &#123;</span><br><span class="line">temp = a[j + <span class="number">1</span>];</span><br><span class="line">a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">a[j] = temp;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="谢谢访问"><a href="#谢谢访问" class="headerlink" title="谢谢访问"></a>谢谢访问</h3><div style=" width:747px; height: 447px; margin:0 auto">   <img src="/images/thank.jpg" style=" margin:0 auto;  ">  </div>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h3&gt;&lt;p&gt;&lt;code&gt;冒泡排序&lt;/code&gt;是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。
    
    </summary>
    
    
      <category term="排序" scheme="http://McKinleyLu.com/categories/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="Bubble_Sort" scheme="http://McKinleyLu.com/categories/%E6%8E%92%E5%BA%8F/Bubble-Sort/"/>
    
    
      <category term="算法" scheme="http://McKinleyLu.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>旋转数组</title>
    <link href="http://mckinleylu.com/2019/09/15/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
    <id>http://mckinleylu.com/2019/09/15/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</id>
    <published>2019-09-15T02:02:11.000Z</published>
    <updated>2019-09-15T03:15:15.531Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个数组，将数组中的元素向右移动 <em>k</em> 个位置，其中 <em>k</em> 是非负数。<a id="more"></a></p><h4 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,5,6,7] 和 k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右旋转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右旋转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure><h4 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [-1,-100,3,99] 和 k = 2</span><br><span class="line">输出: [3,99,-1,-100]</span><br><span class="line">解释: </span><br><span class="line">向右旋转 1 步: [99,-1,-100,3]</span><br><span class="line">向右旋转 2 步: [3,99,-1,-100]</span><br></pre></td></tr></table></figure><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul><li>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</li><li>要求使用空间复杂度为 O(1) 的 <strong>原地</strong> 算法。</li></ul><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>由名思义，此题用到旋转方法。</p><p>我们不妨以[1,2,3,4,5,6,7] 和 k = 3为例，首先[1,2,3,4]反转为[4,3,2,1]；其次，将[5,6,7]反转为[7,6,5];之后对整个数组进行反转，得到结果[5,6,7,1,2,3,4];</p><p>我们发现归并排序的归并函数(Merge())，如果也想让空间复杂度为O(1)，用的也是这种旋转方法</p><p>最后，就是处理好一些极端情况：例如数组长度为0，直接返回；如果，k大于数组长度，则右移次数为为 len % k ，即 k - len。</p><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(len &lt;= <span class="number">1</span> || k &lt; <span class="number">1</span> )&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; len) &#123; k = k % len;&#125;<span class="comment">// 处理 k 大于 数组长度的情况</span></span><br><span class="line">        <span class="keyword">int</span> i = len-k;</span><br><span class="line">        reverse(nums.begin(),nums.begin()+i);</span><br><span class="line">        reverse(nums.begin()+i,nums.end());</span><br><span class="line">        reverse(nums.begin(),nums.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="谢谢访问"><a href="#谢谢访问" class="headerlink" title="谢谢访问"></a>谢谢访问</h3><div style=" width:747px; height: 447px; margin:0 auto">   <img src="/images/thank.jpg" style=" margin:0 auto;  ">  </div>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给定一个数组，将数组中的元素向右移动 &lt;em&gt;k&lt;/em&gt; 个位置，其中 &lt;em&gt;k&lt;/em&gt; 是非负数。
    
    </summary>
    
    
      <category term="LeetcodeDateBase" scheme="http://McKinleyLu.com/categories/LeetcodeDateBase/"/>
    
      <category term="Double Point" scheme="http://McKinleyLu.com/categories/LeetcodeDateBase/Double-Point/"/>
    
    
      <category term="算法" scheme="http://McKinleyLu.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://McKinleyLu.com/tags/leetcode/"/>
    
      <category term="C++" scheme="http://McKinleyLu.com/tags/C/"/>
    
  </entry>
  
</feed>
